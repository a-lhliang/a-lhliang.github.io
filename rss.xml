<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘洪亮Leo的博客</title>
  
  <subtitle>经验分享与记录生活</subtitle>
  <link href="https://lhliang.com/rss.xml" rel="self"/>
  
  <link href="https://lhliang.com/"/>
  <updated>2024-03-20T05:43:38.000Z</updated>
  <id>https://lhliang.com/</id>
  
  <author>
    <name>刘洪亮Leo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nmap使用教程</title>
    <link href="https://lhliang.com/p/7f532a0a.html"/>
    <id>https://lhliang.com/p/7f532a0a.html</id>
    <published>2024-03-19T16:00:00.000Z</published>
    <updated>2024-03-20T05:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nmap介绍"><a href="#Nmap介绍" class="headerlink" title="Nmap介绍"></a>Nmap介绍</h2><p>Nmap（Network Mapper）是一个开放源代码的网络探测和安全审核的工具。它被设计用来发现设备运行的服务以及它们的主机名、操作系统、开放端口和其他相关信息。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>合法授权：确保您有权对局域网进行扫描，未经授权的扫描可能违反法律法规，导致法律问题。</li><li>网络政策：遵守所在网络的使用政策，避免因扫描行为影响网络正常运行。</li><li>隐私保护：扫描时尊重他人隐私，获取的信息需用于合法和正当的目的。</li></ul><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://nmap.org/download.html">https://nmap.org/download.html</a></p><h2 id="扫描局域网内所有活跃的主机"><a href="#扫描局域网内所有活跃的主机" class="headerlink" title="扫描局域网内所有活跃的主机"></a>扫描局域网内所有活跃的主机</h2><pre><code class="bash">nmap -sP 192.168.1.0/24</code></pre><blockquote><p>这里192.168.1.0&#x2F;24代表局域网的网络地址和子网掩码，您需要根据实际情况替换。</p></blockquote><h2 id="扫描特定IP地址的所有端口"><a href="#扫描特定IP地址的所有端口" class="headerlink" title="扫描特定IP地址的所有端口"></a>扫描特定IP地址的所有端口</h2><pre><code class="bash">nmap &lt;IP地址&gt;</code></pre><blockquote><p>替换&lt;IP地址&gt;为您想要扫描的主机地址。</p></blockquote><h2 id="扫描特定IP地址的特定端口"><a href="#扫描特定IP地址的特定端口" class="headerlink" title="扫描特定IP地址的特定端口"></a>扫描特定IP地址的特定端口</h2><pre><code class="bash">nmap -p &lt;端口号&gt; &lt;IP地址&gt;</code></pre><blockquote><p>替换&lt;端口号&gt;和&lt;IP地址&gt;为您想要扫描的端口和主机地址。</p></blockquote><h2 id="扫描并显示所有端口的详细信息"><a href="#扫描并显示所有端口的详细信息" class="headerlink" title="扫描并显示所有端口的详细信息"></a>扫描并显示所有端口的详细信息</h2><pre><code class="bash">nmap -v -p- &lt;IP地址&gt;</code></pre><blockquote><p><code>-v</code>表示详细输出，<code>-p-</code>表示扫描所有端口。</p></blockquote><h2 id="隐藏扫描（SYN扫描）"><a href="#隐藏扫描（SYN扫描）" class="headerlink" title="隐藏扫描（SYN扫描）"></a>隐藏扫描（SYN扫描）</h2><pre><code class="bash">nmap -sS &lt;IP地址&gt;</code></pre><blockquote><p><code>-sS</code>表示使用SYN扫描，这种扫描方式不易被目标主机发现。</p></blockquote><h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><pre><code class="bash">nmap -O &lt;IP地址&gt;</code></pre><blockquote><p><code>-O</code>表示尝试识别目标主机的操作系统。</p></blockquote><h2 id="扫描局域网内的IP和MAC地址"><a href="#扫描局域网内的IP和MAC地址" class="headerlink" title="扫描局域网内的IP和MAC地址"></a>扫描局域网内的IP和MAC地址</h2><pre><code class="bash">sudo nmap -sP -n 192.168.1.0/24</code></pre><blockquote><p><code>-n</code>表示不进行DNS解析，这样可以更快地获取IP和MAC地址。</p></blockquote><h2 id="再次提醒"><a href="#再次提醒" class="headerlink" title="再次提醒"></a>再次提醒</h2><p>使用Nmap时，请务必遵循上述的合法合规性原则，并在确保自己操作权限清晰的情况下进行。</p>]]></content>
    
    
    <summary type="html">这篇文章介绍了使用Nmap如何扫描局域网IP地址需要注意的几点以及一些基础的命令。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="网络安全" scheme="https://lhliang.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="扫描器" scheme="https://lhliang.com/tags/%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>编码规范</title>
    <link href="https://lhliang.com/p/1adaadca.html"/>
    <id>https://lhliang.com/p/1adaadca.html</id>
    <published>2024-03-18T16:00:00.000Z</published>
    <updated>2024-03-19T14:30:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黄金定律"><a href="#黄金定律" class="headerlink" title="黄金定律"></a>黄金定律</h1><p>永远遵循同一套编码规范，不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>标签不要大写，即便是 doctype 标签。</li><li>用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。</li><li>嵌套元素应当缩进一次（即两个空格）。</li><li>对于属性的定义，永远全部使用双引号，绝不要使用单引号。</li><li>不要在自闭合（self-closing）元素的尾部添加斜线 — HTML5 规范 中明确说明斜线是可忽略的。</li><li>不要省略可选的结束标签（closing tag）（例如，<code>&lt;/li&gt;</code> 或 <code>&lt;/body&gt;</code>）。</li></ul><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Page title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot;&gt;    &lt;h1 class=&quot;hello-world&quot;&gt;Hello, world!&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="HTML5-doctype"><a href="#HTML5-doctype" class="headerlink" title="HTML5 doctype"></a>HTML5 doctype</h2><p>为每个 HTML 页面的第一行添加 standards mode（标准模式） 声明，这样能够确保在每个浏览器中拥有一致的展现。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;  &lt;/head&gt;&lt;/html&gt;</code></pre><h2 id="语言属性"><a href="#语言属性" class="headerlink" title="语言属性"></a>语言属性</h2><p>根据 HTML5 规范：<br>强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言。这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。</p><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;  &lt;!-- ... --&gt;&lt;/html&gt;</code></pre><h2 id="IE-兼容模式"><a href="#IE-兼容模式" class="headerlink" title="IE 兼容模式"></a>IE 兼容模式</h2><p>IE 支持通过特定的 <code>&lt;meta&gt;</code> 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的绘制模式。</p><pre><code class="html">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;</code></pre><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致（一般采用 UTF-8 编码）。</p><pre><code class="html">&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;</code></pre><h2 id="引入-CSS-和-JavaScript-文件"><a href="#引入-CSS-和-JavaScript-文件" class="headerlink" title="引入 CSS 和 JavaScript 文件"></a>引入 CSS 和 JavaScript 文件</h2><p>根据 HTML5 规范，在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性，因为 <code>text/css</code> 和 <code>text/javascript</code> 分别是它们的默认值。</p><pre><code class="html">&lt;!-- External CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt;&lt;!-- In-document CSS --&gt;&lt;style&gt;  /* ... */&lt;/style&gt;&lt;!-- JavaScript --&gt;&lt;script src=&quot;code-guide.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="实用为王"><a href="#实用为王" class="headerlink" title="实用为王"></a>实用为王</h2><p>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。</p><h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><p>HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。</p><ul><li><code>class</code></li><li><code>id</code>, <code>name</code></li><li><code>data-*</code></li><li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code></li><li><code>title</code>, <code>alt</code></li><li><code>role</code>, <code>aria-*</code></li></ul><p>class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。</p><pre><code class="html">&lt;a class=&quot;...&quot; id=&quot;...&quot; data-toggle=&quot;modal&quot; href=&quot;#&quot;&gt;  Example link&lt;/a&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot;&gt;&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code></pre><h2 id="布尔（boolean）型属性"><a href="#布尔（boolean）型属性" class="headerlink" title="布尔（boolean）型属性"></a>布尔（boolean）型属性</h2><p>布尔型属性可以在声明时不赋值。XHTML 规范要求为其赋值，但是 HTML5 规范不需要。</p><blockquote><p>元素的布尔型属性如果有值，就是 true，如果没有值，就是 false。</p></blockquote><p>如果一定要为其赋值的话，请参考 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attributes">WhatWG</a> 规范：</p><blockquote><p>如果属性存在，其值必须是空字符串或 […] 属性的规范名称，并且不要在首尾添加空白符。</p></blockquote><p>简单来说，就是不用赋值。</p><pre><code class="html">&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;&lt;select&gt;  &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="减少标签的数量"><a href="#减少标签的数量" class="headerlink" title="减少标签的数量"></a>减少标签的数量</h2><p>编写 HTML 代码时，尽量避免多余的父元素。很多时候，这需要迭代和重构来实现。请看下面的案例：</p><pre><code class="html">&lt;!-- Not so great --&gt;&lt;span class=&quot;avatar&quot;&gt;  &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt;</code></pre><h2 id="JavaScript-生成的标签"><a href="#JavaScript-生成的标签" class="headerlink" title="JavaScript 生成的标签"></a>JavaScript 生成的标签</h2><p>通过 JavaScript 生成的标签让内容变得不易查找、编辑，并且降低性能。能避免时尽量避免。</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><ul><li>用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。</li><li>为选择器分组时，将单独的选择器单独放在一行。</li><li>为了代码的易读性，在每个声明块的左花括号前添加一个空格。</li><li>声明块的右花括号应当单独成行。</li><li>每条声明语句的 : 后应该插入一个空格。</li><li>为了获得更准确的错误报告，每条声明都应该独占一行。</li><li>所有声明语句都应当以分号结尾。最后一条声明语句后面的分号是可选的，但是，如果省略这个分号，你的代码可能更易出错。</li><li>对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如，box-shadow）。</li><li>不要在 rgb()、rgba()、hsl()、hsla() 或 rect() 值的内部的逗号后面插入空格。这样利于从多个属性值（既加逗号也加空- 格）中区分多个颜色值（只加逗号，不加空格）。</li><li>对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，.5 代替 0.5；-.5px 代替 -0.5px）。</li><li>十六进制值应该全部小写，例如，#fff。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。</li><li>尽量使用简写形式的十六进制值，例如，用 #fff 代替 #ffffff。</li><li>为选择器中的属性添加双引号，例如，input[type&#x3D;”text”]。只有在某些情况下是可选的，但是，为了代码的一致性，建议都加上双引号。</li><li>避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px;。</li></ul><pre><code class="css">/* Bad CSS */.selector, .selector-secondary, .selector[type=text] &#123;  padding:15px;  margin:0px 0px 15px;  background-color:rgba(0, 0, 0, 0.5);  box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF&#125;/* Good CSS */.selector,.selector-secondary,.selector[type=&quot;text&quot;] &#123;  padding: 15px;  margin-bottom: 15px;  background-color: rgba(0,0,0,.5);  box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;&#125;</code></pre><h2 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h2><p>相关的属性声明应当归为一组，并按照下面的顺序排列：</p><ol><li>Positioning</li><li>Box model</li><li>Typographic</li><li>Visual</li><li>Misc</li></ol><p>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。</p><p>其他属性只是影响组件的 内部 或者是不影响前两组属性，因此排在后面。</p><pre><code class="css">.declaration-order &#123;  /* Positioning */  position: absolute;  top: 0;  right: 0;  bottom: 0;  left: 0;  z-index: 100;  /* Box-model */  display: block;  float: right;  width: 100px;  height: 100px;  /* Typography */  font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;  line-height: 1.5;  color: #333;  text-align: center;  /* Visual */  background-color: #f5f5f5;  border: 1px solid #e5e5e5;  border-radius: 3px;  /* Misc */  opacity: 1;&#125;</code></pre><h2 id="不要使用-import"><a href="#不要使用-import" class="headerlink" title="不要使用 @import"></a>不要使用 @import</h2><p>与 <code>&lt;link&gt;</code> 标签相比，<code>@import</code> 指令要慢很多，不光增加了额外的请求次数，还会导致不可预料的问题。替代办法有以下几种：</p><p>使用多个 <code>&lt;link&gt;</code> 元素<br>通过 Sass 或 Less 之类的 CSS 预处理器将多个 CSS 文件编译为一个文件<br>通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能</p><pre><code class="css">&lt;!-- Use link elements --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;core.css&quot;&gt;&lt;!-- Avoid @imports --&gt;&lt;style&gt;  @import url(&quot;more.css&quot;);&lt;/style&gt;</code></pre><h2 id="媒体查询（Media-query）的位置"><a href="#媒体查询（Media-query）的位置" class="headerlink" title="媒体查询（Media query）的位置"></a>媒体查询（Media query）的位置</h2><p>将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。下面给出一个典型的实例。</p><pre><code class="css">.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (min-width: 480px) &#123;  .element &#123; ...&#125;  .element-avatar &#123; ... &#125;  .element-selected &#123; ... &#125;&#125;</code></pre><h2 id="带前缀的属性"><a href="#带前缀的属性" class="headerlink" title="带前缀的属性"></a>带前缀的属性</h2><p>当使用特定厂商的带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑。</p><p>在 Textmate 中，使用 <strong>Text → Edit Each Line in Selection</strong> (⌃⌘A)。在 Sublime Text 2 中，使用 <strong>Selection → Add Previous Line</strong> (⌃⇧↑) 和 <strong>Selection → Add Next Line</strong> (⌃⇧↓)。</p><pre><code class="css">/* Prefixed properties */.selector &#123;  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);          box-shadow: 0 1px 2px rgba(0,0,0,.15);&#125;</code></pre><h2 id="单行规则声明"><a href="#单行规则声明" class="headerlink" title="单行规则声明"></a>单行规则声明</h2><p>对于只包含一条声明的样式，为了易读性和便于快速编辑，建议将语句放在同一行。对于带有多条声明的样式，还是应当将声明分为多行。</p><p>这样做的关键因素是为了错误检测 – 例如，CSS 校验器指出在 183 行有语法错误。如果是单行单条声明，你就不会忽略这个错误；如果是单行多条声明的话，你就要仔细分析避免漏掉错误了。</p><pre><code class="css">/* Single declarations on one line */.span1 &#123; width: 60px; &#125;.span2 &#123; width: 140px; &#125;.span3 &#123; width: 220px; &#125;/* Multiple declarations, one per line */.sprite &#123;  display: inline-block;  width: 16px;  height: 15px;  background-image: url(&quot;../img/sprite.png&quot;);&#125;.icon           &#123; background-position: 0 0; &#125;.icon-home      &#123; background-position: 0 -20px; &#125;.icon-account   &#123; background-position: 0 -40px; &#125;</code></pre><h2 id="简写形式的属性声明"><a href="#简写形式的属性声明" class="headerlink" title="简写形式的属性声明"></a>简写形式的属性声明</h2><p>在需要显示地设置所有值的情况下，应当尽量限制使用简写形式的属性声明。常被滥用的简写属性如下：</p><ul><li><code>padding</code></li><li><code>margin</code></li><li><code>font</code></li><li><code>background</code></li><li><code>border</code></li><li><code>border-radius</code></li></ul><p>大部分情况下，我们不需要为简写形式的属性声明指定所有值。例如，HTML 的标题元素只需要设置上、下边距（margin）的值，因此，在必要的时候，只需覆盖这两个值就可以了。<code>0</code> 值表示对浏览器默认值或以前指定的值的覆盖。</p><p>过多地使用属性的简写形式会导致代码出现不必要的覆盖和意外的副作用。</p><pre><code class="css">/* Bad example */.element &#123;  margin: 0 0 10px;  background: red;  background: url(&quot;image.jpg&quot;);  border-radius: 3px 3px 0 0;&#125;/* Good example */.element &#123;  margin-bottom: 10px;  background-color: red;  background-image: url(&quot;image.jpg&quot;);  border-top-left-radius: 3px;  border-top-right-radius: 3px;&#125;</code></pre><h2 id="Less-和-Sass-中的嵌套"><a href="#Less-和-Sass-中的嵌套" class="headerlink" title="Less 和 Sass 中的嵌套"></a>Less 和 Sass 中的嵌套</h2><p>避免不必要的嵌套。这是因为虽然你可以使用嵌套，但是并不意味着应该使用嵌套。只有在必须将样式限制在父元素内（也就是后代选择器），并且存在多个需要嵌套的元素时才使用嵌套。</p><pre><code class="css">// Without nesting.table &gt; thead &gt; tr &gt; th &#123; … &#125;.table &gt; thead &gt; tr &gt; td &#123; … &#125;// With nesting.table &gt; thead &gt; tr &#123;  &gt; th &#123; … &#125;  &gt; td &#123; … &#125;&#125;</code></pre><h2 id="Less-和-Sass-中的操作符"><a href="#Less-和-Sass-中的操作符" class="headerlink" title="Less 和 Sass 中的操作符"></a>Less 和 Sass 中的操作符</h2><p>为了提高可读性，在圆括号中的数学计算表达式的数值、变量和操作符之间均添加一个空格。</p><pre><code class="css">// Bad example.element &#123;  margin: 10px 0 @variable*2 10px;&#125;// Good example.element &#123;  margin: 10px 0 (@variable * 2) 10px;&#125;</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>代码是由人编写并维护的。请确保你的代码能够自描述、注释良好并且易于他人理解。好的代码注释能够传达上下文关系和代码目的。不要简单地重申组件或 class 名称。</p><p>对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。</p><pre><code class="css">/* Bad example *//* Modal header */.modal-header &#123;  ...&#125;/* Good example *//* Wrapping element for .modal-title and .modal-close */.modal-header &#123;  ...&#125;</code></pre><h2 id="class-命名"><a href="#class-命名" class="headerlink" title="class 命名"></a>class 命名</h2><ul><li>class 名称中只能出现小写字符和破折号（dashe）（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。</li><li>避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。</li><li>class 名称应当尽可能短，并且意义明确。</li><li>使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。</li><li>基于最近的父 class 或基本（base） class 作为新 class 的前缀。</li><li>使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。</li><li>在为 Sass 和 Less 变量命名时也可以参考上面列出的各项规范。</li></ul><pre><code class="css">/* Bad example */.t &#123; ... &#125;.red &#123; ... &#125;.header &#123; ... &#125;/* Good example */.tweet &#123; ... &#125;.important &#123; ... &#125;.tweet-header &#123; ... &#125;</code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>对于通用元素使用 class ，这样利于渲染性能的优化。</li><li>对于经常出现的组件，避免使用属性选择器（例如，<code>[class^=&quot;...&quot;]</code>）。浏览器的性能会受到这些因素的影响。</li><li>选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。</li><li>只有在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的 class 时 – 前缀类似于命名空间）。</li></ul><pre><code class="css">/* Bad example */span &#123; ... &#125;.page-container #stream .stream-item .tweet .tweet-header .username &#123; ... &#125;.avatar &#123; ... &#125;/* Good example */.avatar &#123; ... &#125;.tweet-header .username &#123; ... &#125;.tweet .avatar &#123; ... &#125;</code></pre><h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><ul><li>以组件为单位组织代码段。</li><li>制定一致的注释规范。</li><li>使用一致的空白符将代码分隔成块，这样利于扫描较大的文档。</li><li>如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动。</li></ul><pre><code class="css">/* * Component section heading */.element &#123; ... &#125;/* * Component section heading * * Sometimes you need to include optional context for the entire component. Do that up here if it&#39;s important enough. */.element &#123; ... &#125;/* Contextual sub-component or modifer */.element-heading &#123; ... &#125;</code></pre><h2 id="编辑器配置"><a href="#编辑器配置" class="headerlink" title="编辑器配置"></a>编辑器配置</h2><p>将你的编辑器按照下面的配置进行设置，以避免常见的代码不一致和差异：</p><ul><li>用两个空格代替制表符（soft-tab 即用空格代表 tab 符）。</li><li>保存文件时，删除尾部的空白符。</li><li>设置文件编码为 UTF-8。</li><li>在文件结尾添加一个空白行。</li></ul><p>参照文档并将这些配置信息添加到项目的 .editorconfig 文件中。</p>]]></content>
    
    
    <summary type="html">这篇文章介绍了编写一致、灵活和可持续的 HTML 和 CSS 代码的规范都包含哪些内容。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="编码" scheme="https://lhliang.com/tags/%E7%BC%96%E7%A0%81/"/>
    
    <category term="前端开发" scheme="https://lhliang.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>主题标签预览</title>
    <link href="https://lhliang.com/p/9d85188f.html"/>
    <id>https://lhliang.com/p/9d85188f.html</id>
    <published>2024-02-29T07:37:19.000Z</published>
    <updated>2024-03-18T01:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新标签中。。。</p><h2 id="行内文本样式"><a href="#行内文本样式" class="headerlink" title="行内文本样式"></a>行内文本样式</h2><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><h2 id="分栏"><a href="#分栏" class="headerlink" title="分栏"></a>分栏</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="lhlfont icon-arrow-up-line"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="lhlfont icon-arrow-up-line"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="lhlfont icon-arrow-up-line"></i></button></div></div></div><h2 id="label-标签"><a href="#label-标签" class="headerlink" title="label 标签"></a>label 标签</h2><p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p><h2 id="折叠框"><a href="#折叠框" class="headerlink" title="折叠框"></a>折叠框</h2><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://bu.dusays.com/2023/06/01/64788d71c832d.webp"></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://bu.dusays.com/2023/06/01/64788cd5a356b.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div>]]></content>
    
    
    <summary type="html">自用Hexo主题标签效果预览，逐渐更新中。。。</summary>
    
    
    
    <category term="主题教程" scheme="https://lhliang.com/categories/%E4%B8%BB%E9%A2%98%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="主题标签" scheme="https://lhliang.com/tags/%E4%B8%BB%E9%A2%98%E6%A0%87%E7%AD%BE/"/>
    
    <category term="Hexo" scheme="https://lhliang.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 管理 Microsoft Defender防病毒软件</title>
    <link href="https://lhliang.com/p/82cf9516.html"/>
    <id>https://lhliang.com/p/82cf9516.html</id>
    <published>2023-07-31T16:00:00.000Z</published>
    <updated>2024-03-17T11:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Microsoft Defender防病毒扫描完成后，无论是按需扫描还是计划扫描，结果都将被记录，可以查看扫描结果。</p><h2 id="PowerShell查看扫描结果"><a href="#PowerShell查看扫描结果" class="headerlink" title="PowerShell查看扫描结果"></a>PowerShell查看扫描结果</h2><p>使用 PowerShell cmdlet 查看扫描结果</p><p>以下 cmdlet 将返回终结点上的每个检测。 如果存在对同一威胁的多个检测，则会根据每次检测的时间单独列出每个检测：</p><pre><code class="PowerShell">Get-MpThreatDetectionActionSuccess                  : TrueAdditionalActionsBitMask       : 0AMProductVersion               : 4.18.23050.9CleaningActionID               : 2CurrentThreatExecutionStatusID : 1DetectionID                    : &#123;16219B17-0B4C-4F57-9240-E99F1966D48D&#125;DetectionSourceTypeID          : 3DomainUser                     : test\testInitialDetectionTime           : 2023/8/1 14:17:46LastThreatStatusChangeTime     : 2023/8/1 14:18:13ProcessName                    : C:\Windows\explorer.exeRemediationTime                : 2023/8/1 14:18:13Resources                      : &#123;file:_C:\xxx.exe&#125;ThreatID                       : 265744ThreatStatusErrorCode          : 0ThreatStatusID                 : 3PSComputerName                 :</code></pre><ul><li>可以指定 -ThreatID 以将输出限制为仅显示特定威胁的检测。</li><li>恢复隔离区的文件也需要指定 -ThreatID</li></ul><h2 id="还原隔离的文件"><a href="#还原隔离的文件" class="headerlink" title="还原隔离的文件"></a>还原隔离的文件</h2><p><strong>列出所有威胁</strong></p><pre><code class="PowerShell">Get-MpThreatCategoryID       : 23DidThreatExecute : FalseIsActive         : FalseResources        :RollupStatus     : 1SchemaVersion    : 1.0.0.0SeverityID       : 4ThreatID         : 265744ThreatName       : Program:Win32/Wacapew.C!mlTypeID           : 0PSComputerName   :</code></pre><p><strong>恢复隔离区文件到原始位置</strong></p><pre><code class="PowerShell">&amp; &#39;C:\Program Files\Windows Defender\MpCmdRun.exe&#39; -Restore -Name Trojan:Win32/Wacatac.H!ml -AllRestoring the following quarantined items:ThreatName = Trojan:Win32/Wacatac.H!ml   file:C:\xxx\xxx.exe quarantined at 2023/8/1 6:08:22 (UTC) was restored</code></pre><h2 id="管理防火墙排除项"><a href="#管理防火墙排除项" class="headerlink" title="管理防火墙排除项"></a>管理防火墙排除项</h2><p><strong>查看排除项列表</strong></p><p>使用 PowerShell 检索排除列表</p><pre><code class="PowerShell">$WDAVprefs = Get-MpPreference$WDAVprefs.ExclusionExtension$WDAVprefs.ExclusionPathC:\BaiduNetdiskDownloadC:\Users\test\Downloads</code></pre><p><strong>添加排除项</strong></p><p>使用 PowerShell 添加排除项</p><pre><code class="PowerShell">Add-MpPreference -ExclusionPath c:\排除目录</code></pre><p><strong>删除排除项</strong></p><p>使用 PowerShell 移除排除项</p><pre><code class="PowerShell">Remove-MpPreference -ExclusionPath c:\排除目录</code></pre><h2 id="使用-PowerShell-运行扫描"><a href="#使用-PowerShell-运行扫描" class="headerlink" title="使用 PowerShell 运行扫描"></a>使用 PowerShell 运行扫描</h2><p><strong>使用专用命令行工具 mpcmdrun.exe 执行防病毒扫描</strong></p><pre><code class="PowerShell">&amp; &#39;C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.23050.9-0\MpCmdRun.exe&#39; -scan -scantype 1Scan starting...Scan finished.</code></pre><p>ScanType 的值为：</p><ul><li>0 默认，根据配置</li><li>1 快速扫描</li><li>2 完全扫描</li><li>3 文件和目录自定义扫描。</li></ul><p><a href="https://learn.microsoft.com/zh-cn/microsoft-365/security/defender-endpoint/command-line-arguments-microsoft-defender-antivirus?view=o365-worldwide">扫描工具参数参考</a></p><p><strong>脱机扫描</strong></p><pre><code class="PowerShell">Start-MpScan</code></pre>]]></content>
    
    
    <summary type="html">本文介绍了如何使用 PowerShell 管理 Windows 自带的杀毒软件，操作包括查看威胁、隔离区恢复、管理排除项等。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="PowerShell" scheme="https://lhliang.com/tags/PowerShell/"/>
    
    <category term="杀毒软件" scheme="https://lhliang.com/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Citrix ADC 和 CVAD 防火墙规则</title>
    <link href="https://lhliang.com/p/c1bb61b0.html"/>
    <id>https://lhliang.com/p/c1bb61b0.html</id>
    <published>2023-07-29T16:00:00.000Z</published>
    <updated>2024-03-17T03:16:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>防火墙规则根据官方文档和项目实施经验总结得出，不足之处还望指正。</p><h2 id="Citrix-ADC-相关防火墙规则"><a href="#Citrix-ADC-相关防火墙规则" class="headerlink" title="Citrix ADC 相关防火墙规则"></a>Citrix ADC 相关防火墙规则</h2><table><thead><tr><th>源</th><th>目的</th><th>协议和端口</th><th>描述</th></tr></thead><tbody><tr><td>管理计算机</td><td>NSIP&#x2F;SNIP</td><td>TCP 22 80 443 3010 3008</td><td>对 NetScaler 配置 GUI 的 SSH 和 HTTP&#x2F;SSL 访问。TCP 3008&#x2F;3010 是 Java，如果流量已加密，则使用 3008。在 10.5 build 57 及更高版本中不需要 Java</td></tr><tr><td>NSIP&#x2F;SNIP</td><td>DNS服务器</td><td>TCP 53 UDP:53 PING</td><td>PING 用于监测 DNS 状态</td></tr><tr><td>NSIP&#x2F;SNIP</td><td>NTP服务器</td><td>UDP 123</td><td>时间同步</td></tr><tr><td>NSIP</td><td>LDAP服务器（域控制器）</td><td>TCP 389 636（安全LDAP）</td><td>安全 LDAP 允许密码更改过期</td></tr><tr><td>NSIP</td><td>LDAP服务器（域控制器）</td><td>TCP 389 636（安全LDAP）</td><td>监测 LDAP 状态</td></tr><tr><td>NSIP</td><td>RADIUS服务器</td><td>UDP 1812</td><td>RADIUS 用于双因素身份验证</td></tr><tr><td>SNIP</td><td>RADIUS服务器</td><td>UDP 1812</td><td>监测 RADIUS 服务状态</td></tr><tr><td>NSIP</td><td>StoreFront</td><td>TCP 80 443</td><td>监测 StoreFront 服务状态</td></tr><tr><td>StoreFront</td><td>NetScaler Gateway VIP</td><td>TCP 443</td><td>从 StoreFront 服务器到 NetScaler 网关的身份验证回调</td></tr><tr><td>SNIP</td><td>DDC</td><td>TCP 80 443</td><td>Secure Ticket Authorities（STA）</td></tr><tr><td>SNIP</td><td>所有虚拟桌面主机网络</td><td>TCP 1494 2598 UDP 1494 2598 16500-16509</td><td>HDX ICA 会话以及UDP 音频</td></tr><tr><td>所有互联和内部用户</td><td>NetScaler Gateway VIP</td><td>TCP 80 443 UDP 443</td><td>来自浏览器和 Citrix 客户端的连接 用于 UDP 音频的 DTLS</td></tr><tr><td>NSIP</td><td>mfa.cloud.com\trust.citrixworkspacesapi.net</td><td>TCP 443</td><td>本机 OTP 推送（需要 DNS）</td></tr></tbody></table><ul><li>默认情况下，身份验证流量使用 NSIP。</li><li>DNS 服务器使用 ping 进行监测。</li></ul><h2 id="Citrix-CVAD-相关防火墙规则"><a href="#Citrix-CVAD-相关防火墙规则" class="headerlink" title="Citrix CVAD 相关防火墙规则"></a>Citrix CVAD 相关防火墙规则</h2><table><thead><tr><th>源</th><th>目的</th><th>协议和端口</th><th>描述</th></tr></thead><tbody><tr><td>管理计算机</td><td>DDC</td><td>TCP 80 443 3389</td><td>PowerShell RDP 管理 DDC</td></tr><tr><td>DDC</td><td>SQL Server</td><td>TCP 1433 UDP 1433</td><td>连接 SQL 数据库</td></tr><tr><td>DDC</td><td>vCenter</td><td>TCP 443</td><td>连接 vCenter 托管资源</td></tr><tr><td>DDC</td><td>SCVMM（Hyper-V）</td><td>TCP 8100</td><td>连接 SCVMM 托管资源</td></tr><tr><td>DDC</td><td>XenServer</td><td>TCP 80 443</td><td>连接 XenServer 托管资源</td></tr><tr><td>DDC</td><td>Citrix Licensing</td><td>TCP 27000 7279 8023-8083</td><td>连接 Licensing 服务器</td></tr><tr><td>DDC</td><td>所有 VDA</td><td>TCP 80</td><td>Brokering</td></tr><tr><td>所有 VDA</td><td>DDC</td><td>TCP 80</td><td>桌面注册</td></tr><tr><td>所有 VDA</td><td>域控制器</td><td>TCP 3268</td><td>桌面注册</td></tr><tr><td>所有 VDA 和应用服务器</td><td>Remote Desktop Licensing Server</td><td>RPC 和 SMB</td><td>远程桌面许可</td></tr><tr><td>StoreFront</td><td>DDC</td><td>TCP 80 443</td><td>XML Secure Ticket Authority（STA）</td></tr><tr><td>StoreFront</td><td>StoreFront</td><td>TCP 808</td><td>多节点复制</td></tr><tr><td>StoreFront</td><td>域控制器</td><td>TCP 88 135 445 389&#x2F;636 49151-65535</td><td>RPC 组策略 认证</td></tr><tr><td>所有客户端（内网）</td><td>StoreFront（或负载地址）</td><td>TCP 80 443</td><td>内网访问 StoreFront</td></tr><tr><td>所有客户端（内网）</td><td>所有 VDA</td><td>TCP 1494 2598 UDP 1494 2598 16500-16509</td><td>HDX ICA UDP音频</td></tr><tr><td>所有客户端</td><td>Citrix Gateway VIP</td><td>TCP 80 443</td><td>互联网或内网访问 Citrix Gateway</td></tr><tr><td>管理计算机</td><td>Director</td><td>TCP 80 443</td><td>运维 Web 页面</td></tr><tr><td>Director</td><td>DDC</td><td>TCP 80 443</td><td>连接 DDC</td></tr><tr><td>管理计算机</td><td>所有 VDA</td><td>TCP 135 3389</td><td>远程协助</td></tr></tbody></table><ul><li>DDC（Delivery Controllers）</li><li>VDA（Virtual Delivery Agent）</li></ul>]]></content>
    
    
    <summary type="html">文章介绍了 Citrix ADC（应用交付控制器） 和 CVAD（Citrix虚拟应用和桌面） 一般环境下防火墙需要开放的规则。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="虚拟应用和桌面" scheme="https://lhliang.com/tags/%E8%99%9A%E6%8B%9F%E5%BA%94%E7%94%A8%E5%92%8C%E6%A1%8C%E9%9D%A2/"/>
    
    <category term="防火墙规则" scheme="https://lhliang.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99/"/>
    
    <category term="应用交付" scheme="https://lhliang.com/tags/%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>Citrix CVAD 架构和通讯连接</title>
    <link href="https://lhliang.com/p/ccab92c4.html"/>
    <id>https://lhliang.com/p/ccab92c4.html</id>
    <published>2023-07-29T16:00:00.000Z</published>
    <updated>2024-03-17T03:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据官方文档和项目实施经验总结得出，不足之处还望指正。</p><h2 id="Citrix-CVAD-架构"><a href="#Citrix-CVAD-架构" class="headerlink" title="Citrix CVAD 架构"></a>Citrix CVAD 架构</h2><p>Citrix Virtual Apps and Desktops 是虚拟化解决方案。利用这些方案，IT 可以在提供随时随地访问任何设备的同时，控制虚拟机、应用程序、许可和安全性。</p><p>Citrix Virtual Apps and Desktops 允许执行以下操作：</p><ul><li>最终用户独立于设备的操作系统和界面运行应用程序和桌面。</li><li>管理员管理网络并控制来自选定设备或所有设备的访问。</li><li>管理员从单个数据中心管理整个网络。</li></ul><p>Citrix Virtual Apps and Desktops 共享统一的体系结构 FlexCast Management Architecture (FMA)。FMA 的主要功能是可以通过单个站点和集成预配运行多个版本的 Citrix Virtual Apps 或 Citrix Virtual Desktops。</p><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p>下图显示了典型部署（称为“站点”）中的主要组件。</p><p><img src="https://docs.citrix.com/en-us/citrix-virtual-apps-desktops/media/components-new-op.png" alt="典型部署"></p><p><strong>Delivery Controller</strong></p><p>Delivery Controller 是站点的中心管理组件。每个站点有一个或多个 Delivery Controller。至少安装在数据中心内的一个服务器上。为实现站点可靠性和可用性，将 Controller 安装在多个服务器上。如果您的部署中包括虚拟机管理程序或其他服务，Controller 服务将与其进行通信，以：</p><ul><li>分发应用程序和桌面</li><li>对用户进行身份验证和管理用户访问</li><li>代理用户与其桌面和应用程序之间的连接。</li><li>优化用户连接</li><li>平衡这些连接的负载</li></ul><p>Controller 的 Broker Service 跟踪登录的用户和登录位置、用户拥有的会话资源以及用户是否需要重新连接到现有应用程序。Broker Service 运行 PowerShell cmdlet 并通过 TCP 端口 80 与 VDA 上的 Broker Agent 通信。它不可以使用 TCP 端口 443。</p><p>Monitor Service 收集历史数据并将其放置在监视数据库中。此服务使用 TCP 端口 80 或 443。</p><p>来自 Controller 服务的数据存储在站点数据库中。</p><p>Controller 管理桌面的状态，根据需要和管理配置启动和停止桌面。</p><p><strong>数据库</strong></p><p>每个站点至少需要一个 Microsoft SQL Server 数据库，用于存储配置和会话信息。此数据库存储组成 Controller 的服务所收集并管理的数据。在数据中心内安装此数据库，并确保此数据库与 Controller 建立持续型连接。</p><p>站点还使用一个配置日志记录数据库和一个监视数据库。默认情况下，这些数据库与站点数据库安装在相同的位置，但您可以对此进行更改。</p><p><strong>Virtual Delivery Agent (VDA)</strong></p><p>VDA 安装在站点中要供用户使用的各个物理计算机或虚拟机上。这些计算机提供应用程序或桌面。VDA 使计算机能够向 Controller 注册，Controller 进而允许向用户提供它所托管的计算机和资源。VDA 建立并管理计算机与用户设备之间的连接。VDA 还验证 Citrix 许可证是否对用户或会话可用，并应用为会话配置的策略。</p><p>VDA 通过 VDA 中的 Broker Agent 将会话信息传递给 Controller 中的 Broker Service。托管多个插件并收集实时数据的 Broker 代理。它通过 TCP 端口 80 与 Controller 通信。</p><p>“VDA”一词通常用于指代理和安装了该代理的计算机。</p><p>VDA 可用于单会话和多会话 Windows 操作系统。适用于多会话 Windows 操作系统的 VDA 允许多个用户同时连接到服务器。适用于单会话 Windows 操作系统的 VDA 每次仅允许一个用户连接到桌面。</p><p><strong>Citrix StoreFront</strong></p><p>StoreFront 负责对用户进行身份验证，并管理用户访问的桌面和应用程序的存储。它可以托管企业应用商店，使用户可以自助访问您为其提供的桌面和应用程序。StoreFront 还跟踪用户的应用程序订阅、快捷方式名称以及其他数据。这有助于确保用户在多个设备之间具有一致的体验。</p><p><strong>Citrix Workspace 应用程序</strong></p><p>Citrix Workspace 应用程序安装在用户设备和其他端点（例如虚拟桌面）上，使用户能够快速、安全地自助访问文档、应用程序和桌面。通过 Citrix Workspace 应用程序，可以按需访问 Windows、Web 和软件即服务 (SaaS) 应用程序。对于无法安装设备特定的 Citrix Workspace 应用程序软件的设备，适用于 HTML5 的 Citrix Workspace 应用程序通过与 HTML5 兼容的 Web 浏览器提供了一个连接。</p><p><strong>Studio</strong></p><p>可以使用下面两个管理控制台管理您的 Citrix Virtual Apps and Desktops 部署：Web Studio（基于 Web）和 Citrix Studio（基于 Windows）。本产品文档仅涉及 Web Studio。有关 Citrix Studio 的信息，请参阅 Citrix Virtual Apps and Desktops 7 2212 或更早版本。</p><p><strong>Web Studio</strong></p><p>Web Studio 是一个基于 Web 的管理控制台，允许您配置和管理本地 Citrix Virtual Apps and Desktops 部署。它专为改善用户体验而设计，通常比 Citrix Studio（基于 Windows 的管理控制台）响应速度更快。</p><p><strong>Citrix Studio</strong></p><p>Citrix Studio 是在其中配置和管理 Citrix Virtual Apps and Desktops 部署的管理控制台。Citrix Studio 无需在单独的管理控制台中管理应用程序和桌面的交付。Citrix Studio 提供的向导将指导您完成设置环境、创建托管应用程序和桌面的工作负载以及将应用程序和桌面分配给用户的操作。还可以使用 Studio 为站点分配和跟踪 Citrix 许可证。</p><p>Citrix Studio 从 Controller 中的 Broker Service 获取所显示的信息，它通过 TCP 端口 80 通信。</p><p><strong>Citrix Director</strong></p><p>Director 是一款基于 Web 的工具，IT 支持团队和技术支持团队可以利用该工具监控环境和对问题进行故障排除，以避免这些问题危及系统，并可以为最终用户执行支持任务。可以使用一个 Director 部署连接到和监视多个 Citrix Virtual Apps 或 Citrix Virtual Desktops 站点。</p><p>Director 显示：</p><ul><li>来自 Controller 中的 Broker Service 的实时会话数据，其中包括 Broker Service 从 VDA 中的 Broker Agent 获取的数据。</li><li>来自 Controller 中的 Monitor Service 的历史站点数据。</li></ul><p>Director 使用 Citrix Gateway 设备捕获的 ICA 性能和启发数据来基于数据生成分析信息，然后将其呈现给管理员。</p><p>还可以使用 Windows 远程协助通过 Director 查看用户会话并与之交互。</p><p><strong>Citrix 许可证服务器</strong></p><p>许可证服务器管理您的 Citrix 产品许可证。它与 Controller 通信以管理每个用户会话的许可，与 Studio 通信以分配许可证文件。站点必须至少具有一个许可证服务器以存储和管理您的许可证文件。</p><p><strong>虚拟机管理程序或其他服务</strong></p><p>虚拟机管理程序或其他服务托管站点中的虚拟机。这些虚拟机可以是用于托管应用程序和桌面的 VM，也可以是用于托管 Citrix Virtual Apps and Desktops 组件的 VM。虚拟机管理程序安装在完全专用于运行虚拟机管理程序和托管虚拟机的主机计算机上。</p><p>Citrix Virtual Apps and Desktops 支持各种虚拟机管理程序和其他服务。</p><p>虽然许多部署都需要虚拟机管理程序，但您不需要虚拟机管理程序即可提供 Remote PC Access。使用 Provisioning Services (PVS) 预配 VM 时，也不需要虚拟机管理程序。</p><h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><p>以下组件也可以包含在 Citrix Virtual Apps and Desktops 部署中。</p><p><strong>Citrix Provisioning</strong></p><p>Citrix Provisioning（以前称为 Provisioning Services）是在某些版本中提供的一个可选组件。它是 MCS 的备选方式，用于预配虚拟机。MCS 创建主映像的副本，PVS 通过流技术将主映像推送到用户设备。PVS 执行此操作时无需使用虚拟机管理程序，因此，您可以使用它来托管物理机。PVS 与 Controller 通信以向用户提供资源。</p><p><strong>Citrix Gateway</strong></p><p>用户从公司防火墙外部连接时，Citrix Virtual Apps and Desktops 可以使用 Citrix Gateway（以前称为 Access Gateway 和 NetScaler Gateway）技术保护这些与 TLS 的连接的安全性。Citrix Gateway 或 VPX 虚拟设备是在隔离区域 (DMZ) 中部署的 SSL VPN 设备。它通过公司防火墙提供单个安全访问点。</p><p><strong>典型部署的工作原理</strong></p><p>站点由具有专用角色的计算机组成，用于实现可扩展性、高可用性和故障转移，并提供采用安全设计的解决方案。站点包括安装 VDA 的服务器和桌面计算机，以及用于管理访问权限的 Delivery Controller。</p><p><img src="https://docs.citrix.com/en-us/citrix-virtual-apps-desktops/media/deployment-overview.png" alt="典型部署的工作原理图"></p><p>VDA 使用户能够连接到桌面和应用程序。它安装在数据中心内的虚拟机上以实现大多数交付方法，但是也可以安装在物理 PC 上以用于 Remote PC Access。</p><p>Controller 由独立的 Windows 服务组成，用于管理资源、应用程序和桌面，并优化和平衡用户连接。每个站点有一个或多个 Controller。由于会话受延迟、带宽和网络可靠性的影响，因此如有可能，请将所有 Controller 放置在同一个 LAN 中。</p><p>用户绝对不能直接访问 Controller。VDA 充当用户和 Controller 之间的媒介。当用户使用 StoreFront 登录时，其凭据将传递到 Controller 上的 Broker Service。然后，Broker Service 将根据为其设置的策略获取配置文件和可用的资源。</p><h3 id="用户连接的处理方式"><a href="#用户连接的处理方式" class="headerlink" title="用户连接的处理方式"></a>用户连接的处理方式</h3><p>要启动会话，用户将通过用户设备上安装的 Citrix Workspace 应用程序或 StoreFront Web 站点进行连接。</p><p>用户选择所需的物理桌面、虚拟桌面或虚拟应用程序。</p><p>用户的凭据按照此路径进行传递以访问 Controller，Controller 通过与 Broker Service 通信确定所需的资源。Citrix 建议管理员在 StoreFront 上放置一个 SSL 证书以加密来自 Citrix Workspace 应用程序的凭据。</p><p><img src="https://docs.citrix.com/en-us/citrix-virtual-apps-desktops/media/user-connections.png" alt="用户连接的处理方式图"></p><p>Broker Service 决定允许用户访问的桌面和应用程序。</p><p>验证凭据后，有关可用应用程序或桌面的信息将通过 StoreFront-Citrix Workspace 应用程序路径发送回用户。用户选择此列表中的应用程序或桌面时，该信息按照相反路径返回到 Controller。Controller 随后决定托管特定应用程序或桌面的 VDA。</p><p>Controller 将用户的凭据通过消息发送给 VDA，然后将关于用户和连接的所有数据发送给 VDA。VDA 接受连接，并将该信息按相同路径发送回 Citrix Workspace 应用程序。在 StoreFront 上收集一组必需参数。这些参数随后被发送到 Citrix Workspace 应用程序，作为 Citrix-Workspace 应用程序-StoreFront 协议对话的一部分，或者转换为 Independent Computing Architecture (ICA) 文件并下载。只要站点经过正确设置，凭据在整个流程均保留加密状态。</p><p>ICA 文件被复制到用户设备上，并在设备与 VDA 上运行的 ICA 堆栈之间建立直接连接。此连接绕过管理基础结构（Citrix Workspace 应用程序、StoreFront 和 Controller）。</p><p>Citrix Workspace 应用程序与 VDA 之间的连接使用 Citrix Gateway 协议 (CGP)。如果连接丢失，通过会话可靠性功能，用户可以重新连接到 VDA，而无需通过管理基础结构重新启动。可以在 Citrix 策略中启用或禁用会话可靠性。</p><p>客户端连接到 VDA 后，VDA 将通知 Controller 用户已登录。然后，Controller 将此信息发送到站点数据库，并开始在监视数据库中记录数据。</p><h3 id="数据访问的工作方式"><a href="#数据访问的工作方式" class="headerlink" title="数据访问的工作方式"></a>数据访问的工作方式</h3><p>每个 Citrix Virtual Apps and Desktops 会话都将生成 IT 能够通过 Studio 或 Director 访问的数据。通过使用 Studio，管理员可以访问 Broker Agent 中的实时数据，以便管理站点。Director 访问监视数据库中存储的相同数据以及历史数据。</p><p><img src="https://docs.citrix.com/en-us/citrix-virtual-apps-desktops/media/data-access.png" alt="数据访问的工作方式图"></p><p>在 Controller 内部，Broker Service 报告计算机上的每个会话的会话数据，以提供实时数据。监视服务还跟踪实时数据并将其作为历史数据存储在监视数据库中。</p><p>Studio 只与 Broker Service 通信。它只访问实时数据。Director 可以与 Broker Service 通信（通过 Broker Agent 中的插件）以访问站点数据库。</p><h3 id="交付桌面和应用程序"><a href="#交付桌面和应用程序" class="headerlink" title="交付桌面和应用程序"></a>交付桌面和应用程序</h3><p>为计算机目录设置将交付应用程序和桌面的计算机。然后，创建交付组，交付组指定将提供的应用程序和桌面（使用目录中的计算机）以及哪些用户可以访问它们。（可选）之后可以创建应用程序组来管理应用程序的集合。</p><p><strong>计算机目录</strong></p><p>计算机目录是作为单个实体进行管理的虚拟机或物理机集合。这些计算机及其中的应用程序或虚拟桌面是要提供给用户的资源。目录中的所有计算机安装相同的操作系统和相同的 VDA，并且，这些计算机上具有相同的应用程序或虚拟桌面。</p><p>通常，您创建一个主映像，然后使用此主映像在目录中创建完全相同的 VM。对于 VM，您可以为该目录中的计算机指定预配方法：Citrix 工具（Citrix Provisioning 或 MCS）或其他工具。也可以使用您自己的现有映像。在这种情况下，必须单独或统一使用第三方电子软件分发 (ESD) 工具管理目标设备。</p><p>有效的计算机类型包括：</p><ul><li>多会话操作系统：具有多会话操作系统的虚拟机或物理计算机。用于交付 Citrix Virtual Apps 发布的应用程序（也称为基于服务器的托管应用程序）和 Citrix Virtual Apps 发布的桌面（也称为服务器托管的桌面）。这些计算机允许多个用户同时与其建立连接。</li><li>单会话操作系统： 配备单会话操作系统的虚拟机或物理机。用于交付 VDI 桌面 （运行可以有选择地个性化的单会话操作系统的桌面）、VM 托管应用程序（来自单会话操作系统的应用程序）以及托管的物理桌面。一次仅允许一个用户连接到其中的一台计算机。</li><li>Remote PC Access： 支持远程用户从任何运行 Citrix Workspace 应用程序的设备访问其物理办公 PC。办公 PC 通过 Citrix Virtual Desktops 部署进行管理，同时要求在允许列表中指定用户设备。</li></ul><p><strong>交付组</strong></p><p>交付组指定哪些用户可以访问哪些计算机上的哪些应用程序、桌面或两者。交付组包含计算机目录中的计算机和具有站点访问权限的 Active Directory 用户。可以按照用户所属的 Active Directory 组将其分配到您的交付组，因为 Active Directory 组和交付组是对要求相似的用户进行分组的方式。</p><p>每个交付组都可以包含多个目录中的计算机，每个目录可以向多个交付组提供计算机。但是，一台计算机一次只能属于一个交付组。</p><p>可以定义交付组中的用户可以访问的资源。例如，要向不同的用户提供不同的应用程序，可以在一个目录的主映像上安装所有应用程序，并在该目录中创建足够多的计算机以在多个交付组之间分发。然后，可以配置每个交付组，以交付计算机上安装的不同应用程序子集。</p><p><strong>应用程序组</strong></p><p>与使用多个交付组相比，应用程序组提供应用程序管理和资源控制优势：通过使用标记限制功能，可以使用现有计算机来完成多个发布任务，从而节省与部署和管理更多计算机有关的成本。标记限制可以视为对交付组中的计算机进行划分（或分区）。对交付组中的一部分计算机进行隔离和故障排除时，应用程序组也很有用。</p><h2 id="Citrix-CVAD-通讯连接图"><a href="#Citrix-CVAD-通讯连接图" class="headerlink" title="Citrix CVAD 通讯连接图"></a>Citrix CVAD 通讯连接图</h2><p><img src="https://docs.citrix.com/en-us/tech-zone/learn/media/diagrams-posters_virtual-apps-and-desktops_poster.png" alt="CVAD通讯连接图"></p><p>防火墙之间的详细端口号也可以参考我另一篇文章</p><p><a href="https://lhliang.com/p/c1bb61b0.html">Citrix ADC 和 CVAD 防火墙规则</a></p><p>源图<br><a href="https://citrix.sharefile.com/d-sc866e3d7bba34d11b454af88b0e0c512">https://citrix.sharefile.com/d-sc866e3d7bba34d11b454af88b0e0c512</a></p>]]></content>
    
    
    <summary type="html">文章介绍了 Citrix CVAD（Citrix虚拟应用和桌面） 的架构以及各个组件之间的通讯连接图。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="虚拟应用和桌面" scheme="https://lhliang.com/tags/%E8%99%9A%E6%8B%9F%E5%BA%94%E7%94%A8%E5%92%8C%E6%A1%8C%E9%9D%A2/"/>
    
    <category term="Citrix" scheme="https://lhliang.com/tags/Citrix/"/>
    
  </entry>
  
  <entry>
    <title>设置 XenServer 开机自启动虚拟机</title>
    <link href="https://lhliang.com/p/6645695d.html"/>
    <id>https://lhliang.com/p/6645695d.html</id>
    <published>2023-06-14T16:00:00.000Z</published>
    <updated>2024-03-16T14:43:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在XenServer的单机环境中经常需要开关机的维护，关机开机后虚拟机并不会像VMware vSphere一样自动启动，并且原来的XenServer版本是有图形化设置的地方的，新版本的XenServer已经在图形界面中取消了自动启动虚拟机的设置，所以只能通过命令行接口来配置。</p><h2 id="命令行登录XenServer"><a href="#命令行登录XenServer" class="headerlink" title="命令行登录XenServer"></a>命令行登录XenServer</h2><pre><code class="bash">ssh root@XenServerIP</code></pre><h2 id="查看虚拟机和Pool的UUID"><a href="#查看虚拟机和Pool的UUID" class="headerlink" title="查看虚拟机和Pool的UUID"></a>查看虚拟机和Pool的UUID</h2><p>记录需要自启动虚拟机的UUID</p><pre><code class="bash">xe vm-list | morexe pool-list</code></pre><h2 id="配置虚拟机开机自启动"><a href="#配置虚拟机开机自启动" class="headerlink" title="配置虚拟机开机自启动"></a>配置虚拟机开机自启动</h2><pre><code class="bash">xe pool-param-set uuid=&lt;pool_UUID&gt; other-config:auto_poweron=truexe vm-param-set uuid=&lt;VM_UUID&gt; other-config:auto_poweron=true</code></pre><h2 id="查看自启动参数"><a href="#查看自启动参数" class="headerlink" title="查看自启动参数"></a>查看自启动参数</h2><pre><code class="bash">xe pool-param-list uuid=&lt;VM_UUID&gt; ｜ grep auto_poweronxe vm-param-list uuid=&lt;VM_UUID&gt; ｜ grep auto_poweron</code></pre><p>配置完成后可以测试一下，断开XenServer服务器电源，再加电，随后会自动启动虚拟机。</p><h2 id="移除自启动虚拟机"><a href="#移除自启动虚拟机" class="headerlink" title="移除自启动虚拟机"></a>移除自启动虚拟机</h2><pre><code class="bash">xe vm-param-remove uuid=&lt;VM_UUID&gt; other-config:auto_poweron=truexe pool-param-remove uuid=&lt;pool_UUID&gt; other-config:auto_poweron=true</code></pre>]]></content>
    
    
    <summary type="html">本文介绍了如何使用命令行配置XenServer中的指定虚拟机开机自启动。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="XenServer" scheme="https://lhliang.com/tags/XenServer/"/>
    
    <category term="虚拟应用和桌面" scheme="https://lhliang.com/tags/%E8%99%9A%E6%8B%9F%E5%BA%94%E7%94%A8%E5%92%8C%E6%A1%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常见的文件系统以及优缺点对比</title>
    <link href="https://lhliang.com/p/98f4319d.html"/>
    <id>https://lhliang.com/p/98f4319d.html</id>
    <published>2023-05-23T16:00:00.000Z</published>
    <updated>2023-07-30T03:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 支持多种文件系统，以下是一些常见的 Linux 文件系统及其优缺点和区别：</p><h2 id="ext4（第四扩展文件系统）"><a href="#ext4（第四扩展文件系统）" class="headerlink" title="ext4（第四扩展文件系统）"></a>ext4（第四扩展文件系统）</h2><ul><li>优点：广泛使用的文件系统，稳定性高；支持大容量存储和大文件；快速索引和检索；支持日志功能，能够快速恢复文件系统状态；</li><li>缺点：不支持文件和文件名的 Unicode 标准；不适用于移动设备。</li></ul><h2 id="XFS（XFS-文件系统）"><a href="#XFS（XFS-文件系统）" class="headerlink" title="XFS（XFS 文件系统）"></a>XFS（XFS 文件系统）</h2><ul><li>优点：高性能文件系统，适用于大容量存储；支持快速索引和检索；可扩展性强；支持快照和日志功能；</li><li>缺点：不支持文件和文件名的 Unicode 标准；不适用于小容量存储设备。</li></ul><h2 id="btrfs（Btrfs-文件系统）"><a href="#btrfs（Btrfs-文件系统）" class="headerlink" title="btrfs（Btrfs 文件系统）"></a>btrfs（Btrfs 文件系统）</h2><ul><li>优点：先进的文件系统，支持快照、数据压缩和校验等功能；可扩展性强；支持在线文件系统扩容和修复；</li><li>缺点：仍处于实验性阶段，可能不如 ext4 或 XFS 稳定；某些功能可能不完全支持或存在问题。</li></ul><h2 id="F2FS（闪存友好文件系统）"><a href="#F2FS（闪存友好文件系统）" class="headerlink" title="F2FS（闪存友好文件系统）"></a>F2FS（闪存友好文件系统）</h2><ul><li>优点：专为闪存存储设备设计，支持快速读写；减少写入操作对闪存的磨损；支持 TRIM 和压缩等优化功能；</li><li>缺点：不适用于传统磁盘驱动器；不支持大容量存储；兼容性较差。</li></ul><h2 id="ZFS（Zettabyte-文件系统）"><a href="#ZFS（Zettabyte-文件系统）" class="headerlink" title="ZFS（Zettabyte 文件系统）"></a>ZFS（Zettabyte 文件系统）</h2><ul><li>优点：先进的文件系统，支持快照、数据校验和软件 RAID 等功能；可靠性高；支持在线存储池扩容和修复；</li><li>缺点：需要额外的内存和处理能力；在某些 Linux 发行版中的集成和支持可能有限。</li></ul><p>这些文件系统具有不同的特点和用途，选择文件系统取决于你的需求和预期的使用环境。对于大多数常规情况，ext4 是最常见和可靠的选择。如果需要处理大容量存储和高性能需求，XFS 或 btrfs 可能是更好的选择。F2FS 适用于闪存设备，而 ZFS 则适用于对数据完整性和可靠性要求较高的场景。</p>]]></content>
    
    
    <summary type="html">这篇文章讲述了Linux中常用的文件系统，以及各文件系统的优缺点对比，对于大多数常规情况，ext4 是最常见和可靠的选择，ZFS则适用于对数据完整性和可靠性要求较高的场景。</summary>
    
    
    
    <category term="科普文章" scheme="https://lhliang.com/categories/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="Linux" scheme="https://lhliang.com/tags/Linux/"/>
    
    <category term="文件系统" scheme="https://lhliang.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 支持的文件系统以及优缺点对比</title>
    <link href="https://lhliang.com/p/3505e186.html"/>
    <id>https://lhliang.com/p/3505e186.html</id>
    <published>2023-05-23T16:00:00.000Z</published>
    <updated>2023-07-30T03:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 支持多种文件系统，以下是其中一些常见的文件系统及其优缺点和区别：</p><h2 id="HFS-（Mac-OS-扩展格式）"><a href="#HFS-（Mac-OS-扩展格式）" class="headerlink" title="HFS+（Mac OS 扩展格式）"></a>HFS+（Mac OS 扩展格式）</h2><ul><li>优点：良好的兼容性，适用于旧版本的 macOS；支持文件加密和元数据日志；</li><li>缺点：不适用于大容量存储；不支持磁盘分区大小超过 2 TB；不支持文件和文件名的 Unicode 标准。</li></ul><h2 id="APFS（Apple-文件系统）"><a href="#APFS（Apple-文件系统）" class="headerlink" title="APFS（Apple 文件系统）"></a>APFS（Apple 文件系统）</h2><ul><li>优点：支持快照、副本和克隆功能，提供更好的性能和更高的可靠性；支持文件和文件名的 Unicode 标准；更好地适应固态硬盘（SSD）；</li><li>缺点：不支持旧版本的 macOS；在某些情况下可能与旧版软件不兼容。</li></ul><h2 id="ExFAT"><a href="#ExFAT" class="headerlink" title="ExFAT"></a>ExFAT</h2><ul><li>优点：跨平台兼容性强，可在 Windows、macOS 和 Linux 上读写；无文件大小限制；支持闪存存储设备；</li><li>缺点：不支持文件和文件名的 Unicode 标准；不支持文件加密和元数据日志；不适用于系统和应用程序安装。</li></ul><h2 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h2><ul><li>优点：良好的兼容性，适用于 Windows 系统；支持文件加密和访问控制；</li><li>缺点：只能在 macOS 上进行读取，需要额外的软件才能进行写入操作；不适用于系统和应用程序安装。</li></ul><p>这些文件系统具有不同的特点和适用范围，选择文件系统取决于你的需求和预期的使用环境。对于普通用户而言，APFS 是 macOS 的默认文件系统，提供了最佳的性能和功能支持。如果需要与 Windows 或其他操作系统交换数据，ExFAT 是一个不错的选择。若要与 Windows 系统进行更深入的交互，可能需要考虑使用 NTFS 文件系统。</p>]]></content>
    
    
    <summary type="html">这篇文章讲述了macOS的各个文件系统对比，总结来说Mac用户如果需要与 Windows 或其他操作系统交换数据，ExFAT 是一个不错的选择。</summary>
    
    
    
    <category term="科普文章" scheme="https://lhliang.com/categories/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="文件系统" scheme="https://lhliang.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="MacOS" scheme="https://lhliang.com/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Windows 操作系统中的文件系统区别和优缺点</title>
    <link href="https://lhliang.com/p/651ab16f.html"/>
    <id>https://lhliang.com/p/651ab16f.html</id>
    <published>2023-05-22T16:00:00.000Z</published>
    <updated>2023-07-30T03:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows操作系统中，常见的文件系统包括FAT、FAT16、FAT32、exFAT、NTFS和ReFS。它们之间具有以下区别和优缺点：</p><h2 id="FAT（文件分配表）"><a href="#FAT（文件分配表）" class="headerlink" title="FAT（文件分配表）"></a>FAT（文件分配表）</h2><ul><li>优点：FAT是最早的Windows文件系统，具有广泛的兼容性，可以在不同的操作系统和设备上读取和写入数据。它的简单结构使其在某些特定场景下具有一定优势。</li><li>缺点：FAT文件系统具有较大的文件和分区大小限制，不支持文件权限和加密，不具备强大的容错和恢复功能。</li></ul><h2 id="FAT16"><a href="#FAT16" class="headerlink" title="FAT16"></a>FAT16</h2><ul><li>优点：FAT16相对于FAT具有更大的文件和分区大小限制，支持更大的存储容量。</li><li>缺点：FAT16仍然具有较小的文件和分区大小限制，不支持文件权限和加密，不适用于大容量存储。</li></ul><h2 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h2><ul><li>优点：FAT32是FAT文件系统的升级版，支持更大的文件和分区大小，适用于较大容量的存储设备。</li><li>缺点：FAT32仍然有一定的文件和分区大小限制，不支持文件权限和加密，对于大容量文件存储不是最佳选择。</li></ul><h2 id="exFAT"><a href="#exFAT" class="headerlink" title="exFAT"></a>exFAT</h2><ul><li>优点：exFAT是针对闪存设备设计的文件系统，支持更大的文件和分区大小，具有更好的兼容性，可以在Windows和Mac等操作系统上使用。</li><li>缺点：exFAT相对于FAT32在功能和可靠性方面没有明显的优势，仍然不支持文件权限和加密。</li></ul><h2 id="NTFS（新技术文件系统）"><a href="#NTFS（新技术文件系统）" class="headerlink" title="NTFS（新技术文件系统）"></a>NTFS（新技术文件系统）</h2><ul><li>优点：NTFS是Windows默认的文件系统，具有较大的文件和分区大小限制，支持文件权限、加密、压缩和访问控制等高级功能。它具有较好的容错性和恢复能力。</li><li>缺点：NTFS相对于FAT文件系统在一些老旧设备和非Windows系统上的兼容性较差。</li></ul><h2 id="ReFS（可扩展文件系统）"><a href="#ReFS（可扩展文件系统）" class="headerlink" title="ReFS（可扩展文件系统）"></a>ReFS（可扩展文件系统）</h2><ul><li>优点：ReFS是Windows Server 2012引入的新文件系统，具有高度的可靠性、完整性保护和自动修复功能。它支持大容量存储和高级数据管理。</li><li>缺点：ReFS主要面向企业级环境，不是Windows桌面操作系统的默认文件系统，对于普通用户来说使用场景有限。</li></ul><blockquote><p>在选择文件系统时，需要考虑存储设备的容量、文件大小需求、跨平台兼容性、数据安全性、高级功能需求等因素，并选择适合的文件系统。<br>一般而言，NTFS是Windows桌面系统上较常用的文件系统，而exFAT适用于可移动存储设备，如闪存盘和外部硬盘。</p></blockquote>]]></content>
    
    
    <summary type="html">这篇文章介绍了Windows操作系统中的文件系统区别和优缺点，一般而言，NTFS是Windows桌面系统上较常用的文件系统，而exFAT适用于可移动存储设备，如闪存盘和外部硬盘。</summary>
    
    
    
    <category term="科普文章" scheme="https://lhliang.com/categories/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="文件系统" scheme="https://lhliang.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://lhliang.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Btrfs 和 ZFS 的区别以及优缺点</title>
    <link href="https://lhliang.com/p/2721261f.html"/>
    <id>https://lhliang.com/p/2721261f.html</id>
    <published>2023-05-22T16:00:00.000Z</published>
    <updated>2024-03-04T15:19:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Btrfs和ZFS的对比介绍</p><h2 id="Btrfs（B-tree文件系统）"><a href="#Btrfs（B-tree文件系统）" class="headerlink" title="Btrfs（B-tree文件系统）"></a>Btrfs（B-tree文件系统）</h2><p>优点：</p><ol><li>灵活性：Btrfs设计用于适应各种用途，包括单个计算机和大型存储系统。它支持快照、写时复制、在线扩展等功能。</li><li>自愈性：Btrfs具有自动修复功能，可以检测和修复数据损坏或文件系统错误。</li><li>管理工具：Btrfs附带了一组管理工具，使用户可以方便地管理文件系统、快照和子卷。</li><li>压缩和去重：Btrfs支持实时数据压缩和去重，可以节省存储空间。</li></ol><p>缺点：</p><ol><li>稳定性：尽管Btrfs在很多方面已经非常稳定，但仍然被认为是相对较新的文件系统，可能会有一些稳定性方面的问题。</li><li>功能完整性：某些高级功能，如RAID-Z、数据加密等，可能在Btrfs中缺乏或不完善。</li></ol><h2 id="ZFS（Zettabyte文件系统）"><a href="#ZFS（Zettabyte文件系统）" class="headerlink" title="ZFS（Zettabyte文件系统）"></a>ZFS（Zettabyte文件系统）</h2><p>优点：</p><ol><li>数据完整性：ZFS以数据完整性为重点，采用了强大的校验和机制，以检测和修复数据损坏。</li><li>快照和克隆：ZFS具有出色的快照和克隆功能，可以轻松创建、回滚和管理文件系统的快照。</li><li>可扩展性：ZFS支持非常大的存储容量，可以轻松地添加新的存储设备并扩展存储池的容量。</li><li>高级功能：ZFS提供了许多高级功能，如RAID-Z数据保护、数据压缩、数据加密等。</li></ol><p>缺点：</p><ol><li>内存要求：ZFS对系统内存要求较高，特别是在处理大容量存储时，需要足够的内存才能实现最佳性能。</li><li>配置复杂性：ZFS的配置和管理相对复杂，对于不熟悉的用户来说可能需要一些学习和配置时间。</li><li>兼容性：尽管ZFS在大多数主流操作系统上都有支持，但在某些非主流操作系统或特定硬件平台上可能缺乏支持。</li></ol><p>总体而言，Btrfs注重灵活性和易用性，适用于各种规模的存储环境。ZFS则更加注重数据完整性和高级功能，适合需要大容量、高可靠性和高性能的存储环境。选择哪种文件系统应基于具体的需求、操作系统支持以及用户对配置和管理的熟悉程度。</p>]]></content>
    
    
    <summary type="html">这篇文章介绍了Btrfs和ZFS是两种先进的文件系统的优缺点和区别。</summary>
    
    
    
    <category term="科普文章" scheme="https://lhliang.com/categories/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="文件系统" scheme="https://lhliang.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>vSphere with Tanzu 概念以及常用命令</title>
    <link href="https://lhliang.com/p/969a7478.html"/>
    <id>https://lhliang.com/p/969a7478.html</id>
    <published>2023-05-14T00:00:00.000Z</published>
    <updated>2024-03-16T14:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过使用 vSphere with Tanzu，可以将 vSphere 集群转换为在专用资源池中运行 Kubernetes 工作负载的平台。在 vSphere 集群上启用 vSphere with Tanzu 后，会在 Hypervisor 层中直接创建一个 Kubernetes 控制平面。之后，可以通过部署 vSphere Pod 运行 Kubernetes 容器，也可以通过 VMware Tanzu™ Kubernetes Grid™ 服务创建上游 Kubernetes 集群，并在这些集群中运行应用程序。</p><h2 id="什么是-vSphere-with-Tanzu？"><a href="#什么是-vSphere-with-Tanzu？" class="headerlink" title="什么是 vSphere with Tanzu？"></a>什么是 vSphere with Tanzu？</h2><p>使用 vSphere with Tanzu 将 vSphere 转换为在 Hypervisor 层上以本机方式运行 Kubernetes 工作负载的平台。在 vSphere 集群上启用 vSphere with Tanzu 后，可直接在 ESXi 主机上运行 Kubernetes 工作负载，并可在专用资源池中创建上游 Kubernetes 集群。</p><h2 id="什么是-vSphere-Pod？"><a href="#什么是-vSphere-Pod？" class="headerlink" title="什么是 vSphere Pod？"></a>什么是 vSphere Pod？</h2><p>vSphere with Tanzu 引入了一个名为 vSphere Pod 的新构造，它等效于 Kubernetes Pod。vSphere Pod 是一个占用空间较小的虚拟机，可运行一个或多个 Linux 容器。每个 vSphere Pod 根据其容纳的工作负载精确地调整大小，并拥有与该工作负载对应的确切资源预留。它会分配待运行工作负载所需的确切存储、内存和 CPU 资源量。仅配置了 NSX-T Data Center 作为网络连接堆栈的 主管集群 支持 vSphere Pod。</p><h2 id="什么是-Tanzu-Kubernetes-集群？"><a href="#什么是-Tanzu-Kubernetes-集群？" class="headerlink" title="什么是 Tanzu Kubernetes 集群？"></a>什么是 Tanzu Kubernetes 集群？</h2><p>Tanzu Kubernetes 集群是由 VMware 构建、签名和支持的开源 Kubernetes 容器编排平台的完整分发版。可以通过使用 Tanzu Kubernetes Grid 服务 在 主管集群 上置备和运行 Tanzu Kubernetes 集群。主管集群 是启用了 vSphere with Tanzu 的 vSphere 集群。</p><h2 id="何时使用-vSphere-Pod-和-Tanzu-Kubernetes-集群"><a href="#何时使用-vSphere-Pod-和-Tanzu-Kubernetes-集群" class="headerlink" title="何时使用 vSphere Pod 和 Tanzu Kubernetes 集群"></a>何时使用 vSphere Pod 和 Tanzu Kubernetes 集群</h2><p>使用 vSphere Pod 还是 Tanzu Kubernetes Grid 服务置备的 Tanzu Kubernetes 集群，取决于与在主管集群上部署和管理 Kubernetes 工作负载相关的目标。</p><h2 id="Tanzu-Kubernetes-集群操作命令"><a href="#Tanzu-Kubernetes-集群操作命令" class="headerlink" title="Tanzu Kubernetes 集群操作命令"></a>Tanzu Kubernetes 集群操作命令</h2><pre><code class="bash"># 连接到 vSphere with Tanzu 集群kubectl vsphere login --server=10.200.0.2 --vsphere-username administrator@vsphere.local --insecure-skip-tls-verify# 验证目标是否为预期环境kubectl config get-contexts# 如果目标不是预期环境，切换到目标命名空间kubectl config use-context tkgs-ns# 列出可用的虚拟机类绑定kubectl get virtualmachineclassbindings# 列出可用的虚拟机镜像kubectl get virtualmachineimagekubectl get vmimagekubectl describe virtualmachineimage# 查询存储类kubectl get storageclasseskubectl describe storageclasses# 列出当前命名空间中的集群kubectl get tanzukubernetesclusterkubectl get tkc# 列出可用的 Tanzu Kubernetes 版本kubectl get tanzukubernetesreleaseskubectl get tkr# 描述指定的集群，显示表述的状况、状态和事件kubectl describe tanzukubernetescluster CLUSTER-NAME# 列出支持当前命名空间中的集群的集群 API 资源，包括集群 API 项目中的资源以及 Tanzu Kubernetes Grid 服务所用集群 API 提供程序中的资源kubectl get cluster-api# 查看集群 API 集群资源kubectl describe clusters.cluster.x-k8s.io CLUSTER-NAME# 列出支持当前命名空间中的集群节点的虚拟机服务资源kubectl get virtualmachineservicekubectl get vmservice# 列出当前命名空间中的负载均衡器资源，包括用于集群的负载均衡器资源kubectl get loadbalancer# 列出当前命名空间中的持久卷声明资源，包括用于集群的资源kubectl get persistentvolumeclaim# 列出当前命名空间中的 CNS 节点虚拟机附加资源kubectl get cnsnodevmattachment# 列出当前命名空间中的配置映射，包括用于创建集群节点的映射kubectl get configmap# 列出当前命名空间中的密钥，包括用于创建和管理集群节点的密钥kubectl get secret</code></pre><h2 id="Tanzu-Kubernetes-集群网络连接命令"><a href="#Tanzu-Kubernetes-集群网络连接命令" class="headerlink" title="Tanzu Kubernetes 集群网络连接命令"></a>Tanzu Kubernetes 集群网络连接命令</h2><pre><code class="bash"># 查看默认 CNI，即 antrea（除非已更改）除非在集群 YAML 中明确替代，否则使用默认 CNI 创建集群。kubectl get tkgserviceconfigurationsNAME                        DEFAULT CNItkg-service-configuration   antrea# 查看集群节点的虚拟网络。用于验证是否已分配源网络地址转换 (SNAT) IP 地址。kubectl get virtualnetworkNAME                   SNAT             READY   AGEtkgs-cluster-12-vnet   10.191.152.133   True    4h3m# 查看集群节点的虚拟网络接口。用于验证每个集群节点的虚拟机是否已分配 IP 地址。kubectl get virtualmachines -o wideNAME                               POWERSTATE   CLASS               IMAGE                                     PRIMARY-IP    AGEtkgs-cluster-12-control-plane-...  poweredOn    guaranteed-medium   ob-...-v1.21.6---vmware.1-tkg.1.b3d708a   10.244.0.66   4h6mtkgs-cluster-12-worker-...         poweredOn    guaranteed-medium   ob-...-v1.21.6---vmware.1-tkg.1.b3d708a   10.244.0.68   4h3mtkgs-cluster-12-worker-...         poweredOn    guaranteed-medium   ob-...-v1.21.6---vmware.1-tkg.1.b3d708a   10.244.0.67   4h3m# 查看每个集群节点的虚拟机服务。用于验证状态是否已更新，是否包括负载均衡器虚拟 IP (VIP) 地址。kubectl get virtualmachineservicesNAME                                    TYPE           AGEtkgs-cluster-12-control-plane-service   LoadBalancer   3h53m# 查看为集群 API 访问创建的 Kubernetes 服务负载均衡器。用于验证是否已分配外部 IP。使用 curl 验证能否使用负载均衡器服务的外部 IP 地址和端口来访问 API。kubectl get services -n NAMESPACEcurl -k https://EXTERNAL-IP:PORT/healthz# 集群的控制平面节点（端点）。用于验证是否每个端点均已创建并包含在端点池中。kubectl get endpointsNAME                                    ENDPOINTS          AGEtkgs-cluster-12-control-plane-service   10.244.0.66:6443   3h44m</code></pre><h2 id="使用-TKGS-v1alpha2-API-置备-TKGS"><a href="#使用-TKGS-v1alpha2-API-置备-TKGS" class="headerlink" title="使用 TKGS v1alpha2 API 置备 TKGS"></a>使用 TKGS v1alpha2 API 置备 TKGS</h2><pre><code class="yaml">apiVersion: run.tanzu.vmware.com/v1alpha2kind: TanzuKubernetesClustermetadata:  name: tkg-cluster-1  namespace: tanzu-kubernetes-gridspec:  topology:    controlPlane:      replicas: 3      vmClass: best-effort-large      storageClass: goldsp      tkr:          reference:          name: v1.22.9---vmware.1-tkg.1.cc71bc8    nodePools:    - name: worker-nodepool-a1      replicas: 3      vmClass: best-effort-large      storageClass: goldsp      tkr:          reference:          name: v1.22.9---vmware.1-tkg.1.cc71bc8  settings:    storage:      defaultClass: goldsp    network:      cni:        name: antrea      services:        cidrBlocks: [&quot;10.95.0.0/23&quot;]      pods:        cidrBlocks: [&quot;10.243.0.0/20&quot;]      serviceDomain: tkg.io</code></pre>]]></content>
    
    
    <summary type="html">这篇文章讲的是作者记录的 vSphere with Tanzu 概念以及常用命令汇总。</summary>
    
    
    
    <category term="容器技术" scheme="https://lhliang.com/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VMware" scheme="https://lhliang.com/tags/VMware/"/>
    
    <category term="Tanzu" scheme="https://lhliang.com/tags/Tanzu/"/>
    
    <category term="TKGS" scheme="https://lhliang.com/tags/TKGS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客随机友链，加速加载</title>
    <link href="https://lhliang.com/p/9f6cbcb.html"/>
    <id>https://lhliang.com/p/9f6cbcb.html</id>
    <published>2023-05-12T16:00:00.000Z</published>
    <updated>2024-03-18T01:01:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Butterfly主题的博友都在对博客随机友链功能做优化。</p><h2 id="随机友链优化案例"><a href="#随机友链优化案例" class="headerlink" title="随机友链优化案例"></a>随机友链优化案例</h2><p><a href="https://blog.zhheo.com/">张洪Heo</a> 使用的是js读取本地json文件，通过编辑json文件即可实现增删改友链。</p><p>部分代码如下，详细可以看作者源码</p><pre><code class="javascript">    addFriendLinksInFooter: function() &#123;        fetch(&quot;/zhheo/friendlink.json&quot;).then((e=&gt;e.json())).then((e=&gt;&#123;            var t = []              , o = -1;            for (const n of e) &#123;                const e = n.link_list;                for (let n = 0; n &lt; Math.min(e.length, 1); n++) &#123;                    let n = Math.floor(Math.random() * e.length);                    for (; n === o &amp;&amp; e.length &gt; 1; )                        n = Math.floor(Math.random() * e.length);                    o = n,                    t.push(&#123;                        name: e[n].name,                        link: e[n].link                    &#125;),                    e.splice(n, 1)                &#125;            &#125;            t.pop();            var n = &quot;&quot;;            for (let e = 0; e &lt; t.length; ++e) &#123;                var a = t[e];                n += `&lt;a class=&#39;footer-item&#39; href=&#39;$&#123;a.link&#125;&#39;  target=&quot;_blank&quot; rel=&quot;noopener nofollow&quot;&gt;$&#123;a.name&#125;&lt;/a&gt;`            &#125;            n += &quot;&lt;a class=&#39;footer-item&#39; href=&#39;/link/&#39;&gt;更多&lt;/a&gt;&quot;,            document.getElementById(&quot;friend-links-in-footer&quot;).innerHTML = n        &#125;        ))    &#125;</code></pre><p><a href="https://blog.jayhrn.com/posts/711b9d78.html">jayhrn</a> 使用的是Hexo过滤器，读取的博客友链页面的所有链接。</p><p>部分代码如下，详细可以看<a href="https://blog.jayhrn.com/posts/711b9d78.html">作者原文</a></p><pre><code class="javascript">hexo.extend.filter.register(&#39;after_render:html&#39;, function (data) &#123;    const flinks = []    hexo.locals.get(&#39;data&#39;).link.map(function (list) &#123;        list.link_list.map(function (flink) &#123;            flinks.push(flink)        &#125;)    &#125;)    data += `&lt;script&gt;        function getRandomFlink(num) &#123;            let AllFinlks=$&#123;JSON.stringify(flinks)&#125;            let randomLinks = [];            while (randomLinks.length &lt; num &amp;&amp; AllFinlks.length &gt; 0) &#123;                let index = Math.floor(Math.random() * AllFinlks.length);                randomLinks.push(AllFinlks.splice(index, 1)[0]);            &#125;            return randomLinks;        &#125;        &lt;/script&gt;`    return data&#125;)</code></pre><h2 id="测试优化后的效果"><a href="#测试优化后的效果" class="headerlink" title="测试优化后的效果"></a>测试优化后的效果</h2><p>因为不想维护过多的json文件，所以使用jayhrn的逻辑做了测试，效果不错，速度快并且稳定，不依赖其他json文件。</p><p>随机友链在我的博客里面有三个功能：</p><ol><li>首页右上角点击 提示跳转 指定友链地址；</li><li>全站页脚左下角点击 随机友链 使用新窗口打开友链地址；</li><li>全站页脚随机展示 两个友链 点击后新窗口打开友链地址；</li></ol><h2 id="基于jayhrn的逻辑首次修改"><a href="#基于jayhrn的逻辑首次修改" class="headerlink" title="基于jayhrn的逻辑首次修改"></a>基于jayhrn的逻辑首次修改</h2><p>更新<code>themes/butterfly/scripts/helpers/random.js</code>文件</p><pre><code class="javascript">/** * 随机友链 */hexo.extend.filter.register(&#39;after_render:html&#39;, function (data) &#123;    const flinks = []    hexo.locals.get(&#39;data&#39;).link.map(function (list) &#123;        list.link_list.map(function (flink) &#123;            flinks.push(flink)        &#125;)    &#125;)    data += `&lt;script&gt;        function toRandomFlink() &#123;            let flinksTo=$&#123;JSON.stringify(flinks)&#125;            window.open(flinksTo[Math.floor(Math.random() * flinksTo.length)].link)        &#125;        function RandomFlink() &#123;            let flinksRan=$&#123;JSON.stringify(flinks)&#125;            let e = flinksRan[Math.floor(Math.random() * flinksRan.length)]            return e        &#125;        function getRandomFlink(num) &#123;            let flinksGet=$&#123;JSON.stringify(flinks)&#125;            let randomLinks = [];            while (randomLinks.length &lt; num &amp;&amp; flinksGet.length &gt; 0) &#123;                let index = Math.floor(Math.random() * flinksGet.length);                randomLinks.push(flinksGet.splice(index, 1)[0]);            &#125;            return randomLinks;        &#125;        &lt;/script&gt;`    return data&#125;)</code></pre><p>修改引用js的函数</p><pre><code class="javascript">// 添加随机友链提示跳转function travelling() &#123;    let fetchUrl = RandomFlink()    if(fetchUrl) &#123;        var name = fetchUrl.name;        var link = fetchUrl.link;        let msg = &quot;点击前往按钮进入随机一个友链，不保证跳转网站的安全性和可用性。本次随机到的是本站友链：「&quot; + name + &quot;」&quot;;        document.styleSheets[0].addRule(&#39;:root&#39;, &#39;--LHL-snackbar-time:&#39; + 8000 + &#39;ms!important&#39;);        Snackbar.show(&#123;            text: msg,            duration: 8000,            pos: &#39;top-center&#39;,            actionText: &#39;前往&#39;,            onActionClick: function (element) &#123;                $(element).css(&#39;opacity&#39;, 0);                window.open(link, &#39;_blank&#39;);            &#125;        &#125;);    &#125;&#125;</code></pre><pre><code class="javascript">// 添加底部友链addFriendLinksInFooter: function () &#123;    let randomFriendLinks=getRandomFlink(2)    let htmlText = &#39;&#39;;    for (let i = 0; i &lt; randomFriendLinks.length; ++i) &#123;        let item = randomFriendLinks[i]        htmlText += `&lt;a class=&#39;footer-item&#39; href=&#39;$&#123;item.link&#125;&#39; target=&quot;_blank&quot; rel=&quot;noopener nofollow&quot;&gt;$&#123;item.name&#125;&lt;/a&gt;`;    &#125;    htmlText += `&lt;a class=&#39;footer-item&#39; href=&#39;/link&#39;&gt;更多&lt;/a&gt;`    document.getElementById(&quot;friend-links-in-footer&quot;).innerHTML = htmlText;&#125;,</code></pre><pre><code class="html">// 添加随机友链直接跳转&lt;a class=&quot;footer-item&quot; onclick=&quot;toRandomFlink()&quot; data-pjax-state=&quot;&quot;&gt;随机友链&lt;/a&gt;</code></pre><p>测试结果还是比较满意，但是有个小问题，就是前端页面会生成三组相同的数组，友链越多占用的前端响应时间越多，所以最大化前端性能，第二次修改代码。</p><h2 id="二次修改"><a href="#二次修改" class="headerlink" title="二次修改"></a>二次修改</h2><p>修改为使前端将友链生成一组数组，然后随机友链的三个功能使用时分别浅拷贝即可。</p><p>更新<code>themes/butterfly/scripts/helpers/random.js</code>文件</p><pre><code class="javascript">/** * 随机友链 */hexo.extend.filter.register(&#39;after_render:html&#39;, function (data) &#123;    const flinks = []    hexo.locals.get(&#39;data&#39;).link.map(function (list) &#123;        list.link_list.map(function (flink) &#123;            flinks.push(flink)        &#125;)    &#125;)    data += `&lt;script&gt;let flinksAll=$&#123;JSON.stringify(flinks)&#125;;&lt;/script&gt;`    return data&#125;)</code></pre><p>修改引用js的函数</p><pre><code class="javascript">// 添加随机友链提示跳转function travelling() &#123;    let flinksRandom = Array.from(flinksAll);    let fetchUrl = flinksRandom[Math.floor(Math.random() * flinksRandom.length)]    if(fetchUrl) &#123;        var name = fetchUrl.name;        var link = fetchUrl.link;        let msg = &quot;点击前往按钮进入随机一个友链，不保证跳转网站的安全性和可用性。本次随机到的是本站友链：「&quot; + name + &quot;」&quot;;        document.styleSheets[0].addRule(&#39;:root&#39;, &#39;--LHL-snackbar-time:&#39; + 8000 + &#39;ms!important&#39;);        Snackbar.show(&#123;            text: msg,            duration: 8000,            pos: &#39;top-center&#39;,            actionText: &#39;前往&#39;,            onActionClick: function (element) &#123;                $(element).css(&#39;opacity&#39;, 0);                window.open(link, &#39;_blank&#39;);            &#125;        &#125;);    &#125;&#125;,// 添加底部友链直达function toRandomFlink() &#123;    let flinksTo = Array.from(flinksAll);    window.open(flinksTo[Math.floor(Math.random() * flinksTo.length)].link)&#125;</code></pre><pre><code class="javascript">// 添加底部友链addFriendLinksInFooter: function () &#123;    let flinksFooter = Array.from(flinksAll);     let randomFriendLinks = [];    while (randomFriendLinks.length &lt; 2 &amp;&amp; flinksFooter.length &gt; 0) &#123;        let index = Math.floor(Math.random() * flinksFooter.length);        randomFriendLinks.push(flinksFooter.splice(index, 1)[0]);    &#125;    let htmlText = &#39;&#39;;    for (let i = 0; i &lt; randomFriendLinks.length; ++i) &#123;        let item = randomFriendLinks[i]        htmlText += `&lt;a class=&#39;footer-item&#39; href=&#39;$&#123;item.link&#125;&#39; target=&quot;_blank&quot; rel=&quot;noopener nofollow&quot;&gt;$&#123;item.name&#125;&lt;/a&gt;`;    &#125;    htmlText += `&lt;a class=&#39;footer-item&#39; href=&#39;/link&#39;&gt;更多&lt;/a&gt;`    document.getElementById(&quot;friend-links-in-footer&quot;).innerHTML = htmlText;&#125;</code></pre><p>至此修改完成，效果也不错，不过js的语法可能比较基础，希望可以抛砖引玉，有更高级写法的大佬欢迎讨论。</p>]]></content>
    
    
    <summary type="html">这篇文章讲的是基于jayhrn的逻辑对博客随机友链功能做个性化调整，满足使用需求，作者编写的比较基础，希望可以抛砖引玉。</summary>
    
    
    
    <category term="主题教程" scheme="https://lhliang.com/categories/%E4%B8%BB%E9%A2%98%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Hexo" scheme="https://lhliang.com/tags/Hexo/"/>
    
    <category term="前端开发" scheme="https://lhliang.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Butterfly" scheme="https://lhliang.com/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>轻松实现网站状态监测面板</title>
    <link href="https://lhliang.com/p/f0a2480b.html"/>
    <id>https://lhliang.com/p/f0a2480b.html</id>
    <published>2023-05-08T16:00:00.000Z</published>
    <updated>2024-03-16T14:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>轻松实现一个基于 UptimeRobot API 的在线状态面板</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_10-55-00.webp!articlesimg" alt="最终效果"></p><h2 id="准备API"><a href="#准备API" class="headerlink" title="准备API"></a>准备API</h2><p>需要先到 UptimeRobot 添加站点监控，并在 My Settings 页面获取 API Key</p><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_10-56-59.webp!articlesimg" alt="注册登录"></p><p>新建监测站点</p><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_11-00-21.webp!articlesimg" alt="新建监测"></p><p>免费账户只能监测HEAD，不过也足够用了</p><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_11-02-17.webp!articlesimg" alt="监测设置"></p><p>可以设置监测告警，及时发现站点故障</p><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_11-02-52.webp!articlesimg" alt="监测告警"></p><p>可以添加多个监测的站点和服务</p><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_11-03-16.webp!articlesimg" alt="添加多个"></p><p>查看并记录所有站点的API，后面会用</p><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_11-04-25.webp!articlesimg" alt="复制API"></p><h2 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h2><p>这里部署到vercel（采用vercel演示）如果有网站空间或云服务器，可以直接将前端部署到自己的新站点</p><p>Fork 以下项目，然后修改<code>public/config.js</code>,添加自己的API并修改名称等，可以添加多个API</p><p><a href="https://github.com/yb/uptime-status">uptime-status</a></p><p><img src="https://cdn.lhliang.com/img/upload/2023-05-09_12-22-44.webp!articlesimg" alt="增加API和修改名字等"></p><h2 id="部署前端到vercel"><a href="#部署前端到vercel" class="headerlink" title="部署前端到vercel"></a>部署前端到vercel</h2><p>选择自己的github项目导入，部署类型选择other</p><p><a href="https://vercel.com/new" title="部署到vercel">vercel部署</a></p><p>部署完成后，添加自己的域名并做好CNAME解析（默认vercel域名不可直接使用），就可以使用了。</p>]]></content>
    
    
    <summary type="html">这篇文章介绍了如何使用 UptimeRobot API 结合github的前端项目，部署到 vercel 展现。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="前端开发" scheme="https://lhliang.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="网站状态" scheme="https://lhliang.com/tags/%E7%BD%91%E7%AB%99%E7%8A%B6%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Windows 系统信息显示小工具 BgInfo</title>
    <link href="https://lhliang.com/p/6d78b700.html"/>
    <id>https://lhliang.com/p/6d78b700.html</id>
    <published>2023-04-28T23:05:50.000Z</published>
    <updated>2024-03-16T14:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>当系统管理员在维护Windows系统的时候，经常会操作各种操作指令查看IP地址、DNS、计算机名、系统配置等，往往需要消耗一部分时间和精力。</p><p>使用BGInfo小工具可以自动在桌面背景上显示有关 Windows 计算机的相关信息，例如计算机名称、IP 地址、Service Pack 版本等。 可以编辑任何字段以及字体和背景色。</p><blockquote><p>BGInfo小工具是编辑桌面背景并重新展示桌面壁纸，所以并不会消耗系统资源（如有壁纸循环切换软件不建议共用）。</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>发布时间： 2022 年 9 月 29 日</p><p><a href="https://download.sysinternals.com/files/BGInfo.zip">下载BgInfo v4.32</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>软件为直接执行程序，下载解压到非临时目录，比如<code>c:\BGInfo\</code></p><p><img src="https://cdn.lhliang.com/img/upload/2023-04-29_08-00-32.jpg!articlesimg" alt="2023-04-29_08-00-32.jpg"></p><p>运行 BGInfo 时，会显示其默认桌面背景的外观和内容。 如果不做任何更改，它将在 10 秒倒计时计时器过期后自动应用这些设置并退出。</p><p><img src="https://cdn.lhliang.com/img/upload/2023-04-29_08-00-57.jpg!articlesimg" alt="2023-04-29_08-00-57.jpg"></p><p>默认应用后的效果如下图所示：</p><p><img src="https://cdn.lhliang.com/img/upload/2023-04-29_08-01-53.jpg!articlesimg" alt="2023-04-29_08-01-53.jpg"></p><h2 id="个性调整"><a href="#个性调整" class="headerlink" title="个性调整"></a>个性调整</h2><p>可以运行软件后点击倒计时按钮，然后自定义所有显示内容</p><p><img src="https://cdn.lhliang.com/img/upload/2023-04-29_08-08-49.jpg!articlesimg" alt="2023-04-29_08-08-49.jpg"></p><p>自定义后，需要手动修改回自己的壁纸，然后应用这个最新的配置，效果就会显示出来</p><p><img src="https://cdn.lhliang.com/img/upload/2023-04-29_08-09-25.jpg!articlesimg" alt="2023-04-29_08-09-25.jpg"></p><h2 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h2><p>默认运行只会生效一次，如果需要每次开机后自动执行需要将软件加入到开启自启动文件夹。</p><p>右键软件程序，发送快捷方式到桌面</p><p><img src="https://cdn.lhliang.com/img/upload/2023-04-29_08-27-50.jpg!articlesimg" alt="2023-04-29_08-27-50.jpg"></p><p>然后，将快捷方式拖到’自启动文件夹’里即可</p><p><img src="https://cdn.lhliang.com/img/upload/2023-04-29_08-26-59.jpg!articlesimg" alt="2023-04-29_08-26-59.jpg"></p><p>部分操作系统的自启动路径为：<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</code></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>客户端：Windows 8.1及更高。</p><p>服务器：Windows Server 2012及更高版本。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>更详细的参数设置可以参考<a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/bginfo">微软文档介绍</a>，如有疑问可以留言讨论。</p>]]></content>
    
    
    <summary type="html">这篇文章介绍了一款Windows系统信息显示小工具 BgInfo。使用该工具可以自动在桌面背景上显示Windows计算机相关信息，如计算机名称、IP地址、Service Pack版本等。用户可以编辑任何字段以及字体和背景色。BGInfo小工具是编辑桌面背景并重新展示桌面壁纸，不会消耗系统资源，支持Windows 8.1及更高版本客户端和Windows Server 2012及更高版本服务器。</summary>
    
    
    
    <category term="软件分享" scheme="https://lhliang.com/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Windows" scheme="https://lhliang.com/tags/Windows/"/>
    
    <category term="Sysinternals" scheme="https://lhliang.com/tags/Sysinternals/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安装并使用 Butterfly 主题</title>
    <link href="https://lhliang.com/p/404f0b62.html"/>
    <id>https://lhliang.com/p/404f0b62.html</id>
    <published>2023-04-19T16:00:00.000Z</published>
    <updated>2024-03-18T00:57:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文章为转载整理链接分享，包含了安装Hexo、安装Butterfly主题、主题设置等</p><h2 id="Hexo-安装参考以下官方教程"><a href="#Hexo-安装参考以下官方教程" class="headerlink" title="Hexo 安装参考以下官方教程"></a>Hexo 安装参考以下官方教程</h2><div class="tag-link"><a class="tag-Link" target="_blank" href="https://hexo.io/zh-cn/docs/">        <div class="tag-link-tips">引用站外地址</div>        <div class="tag-link-bottom">            <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/hexo.io/zh-cn/docs/.png);"></div>            <div class="tag-link-right">                <div class="tag-link-title">Hexo 安装文档</div>                <div class="tag-link-sitename">Hexo</div>            </div>            <i class="lhlfont icon-arrow-right-s-line"></i>        </div>        </a></div><h2 id="使用-Butterfly-主题参考以下官方教程"><a href="#使用-Butterfly-主题参考以下官方教程" class="headerlink" title="使用 Butterfly 主题参考以下官方教程"></a>使用 Butterfly 主题参考以下官方教程</h2><div class="tag-link"><a class="tag-Link" target="_blank" href="https://butterfly.js.org/posts/21cfbf15/">        <div class="tag-link-tips">引用站外地址</div>        <div class="tag-link-bottom">            <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/butterfly.js.org/posts/21cfbf15/.png);"></div>            <div class="tag-link-right">                <div class="tag-link-title">Butterfly 安装文档</div>                <div class="tag-link-sitename">Jerry</div>            </div>            <i class="lhlfont icon-arrow-right-s-line"></i>        </div>        </a></div><p>原文作者已经写的很好了，不用过多介绍。</p>]]></content>
    
    
    <summary type="html">本文章为转载整理链接分享，包含了安装Hexo、安装Butterfly主题、主题设置等</summary>
    
    
    
    <category term="转载分享" scheme="https://lhliang.com/categories/%E8%BD%AC%E8%BD%BD%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Hexo" scheme="https://lhliang.com/tags/Hexo/"/>
    
    <category term="前端开发" scheme="https://lhliang.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Butterfly" scheme="https://lhliang.com/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>识别 ESXi 的存储性能问题</title>
    <link href="https://lhliang.com/p/593bfb23.html"/>
    <id>https://lhliang.com/p/593bfb23.html</id>
    <published>2022-10-31T10:26:26.000Z</published>
    <updated>2024-03-17T03:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很多项目或者客户自建的VMware环境中（FC SAN 或 IP SAN）经常碰到虚拟机响应时间过长影响业务应用的运行，在虚拟化平台或者云管中还会发现存储路径延迟的报警。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>传统集中式存储出现存储性能问题的常见原因有如下几种：</p><ul><li>服务器与存储的SAN链路出现问题；</li><li>存储系统的 I&#x2F;O 性能已经无法支撑现有应用；</li><li>服务器的多路径故障；</li></ul><h2 id="识别故障原因"><a href="#识别故障原因" class="headerlink" title="识别故障原因"></a>识别故障原因</h2><p>可以使用交互式 esxtop 实用程序查看 VMware ESX 主机的各种设备的 I&#x2F;O 指标。<br><a href="https://docs.vmware.com/cn/VMware-vSphere/7.0/com.vmware.esxi.install.doc/GUID-F9234F4A-FD6A-477B-B7BA-28EB6B08CE82.html" title="启用 ESXi Shell 和 SSH 访问">启用 ESXi Shell 和 SSH 访问</a>，通过putty等软件远程到ESXi主机。</p><p>要监控每个 HBA 的存储性能，执行以下操作：</p><ol><li>在命令行键入 esxtop 以启动 esxtop。</li><li>按 d 切换到磁盘视图（HBA 模式）。</li><li>要查看完整的设备名称，请按 SHIFT + L 并在“更改名称字段大小”中输入 36。</li><li>按 f 修改显示的字段。</li><li>按 b、c、d、e、h 和 j 切换字段，然后按 Enter。</li><li>按 s，接着按 2 将更新时间间隔改为 2 秒，然后按 Enter。</li></ol><p>要按每个 LUN 监控存储性能，请执行以下操作：</p><ol><li>从命令行键入 esxtop 以启动 esxtop。</li><li>按 u 切换到磁盘视图（LUN 模式）。</li><li>按 f 修改显示的字段。</li><li>按 b、c、f 和 h 切换字段，然后按 Enter。</li><li>按 s，接着按 2 将更新时间间隔改为 2 秒，然后按 Enter。</li></ol><p>要增加 esxtop 中设备字段的宽度以显示完整的 naa id，请执行以下操作：</p><ol><li>在命令行键入 esxtop 以启动 esxtop。</li><li>按 u 切换到磁盘设备显示。</li><li>按 L 更改名称字段大小。</li><li>输入值 36 以显示完整的 naa 标识符。</li></ol><blockquote><p>注意：务必使用大写字母 L。</p></blockquote><p>要按每个虚拟机监控存储性能，请执行以下操作：</p><ol><li>在命令行键入 esxtop 以启动 esxtop。</li><li>键入 v 切换到磁盘视图（虚拟机模式）。</li><li>按 f 修改显示的字段。</li><li>按 b、d、e、h 和 j 切换字段，然后按 Enter。</li><li>按 s，接着按 2 将更新时间间隔改为 2 秒，然后按 Enter。</li></ol><p>各项指标说明：</p><table><thead><tr><th>指标</th><th>描述</th></tr></thead><tbody><tr><td>CMDS&#x2F;s</td><td>这是指每秒命令总数，包括 IOPS（每秒输入&#x2F;输出操作数）和其他 SCSI 命令，如 SCSI reservations、locks、vendor string requests、unit attention 等要发送到或发送自受监控设备或虚拟机的命令。在大多数情况下，除非有大量元数据操作（如 SCSI 预留），否则 CMDS&#x2F;s &#x3D; IOPS。</td></tr><tr><td>DAVG&#x2F;cmd</td><td>这是发送给设备的每个命令的平均响应时间（以毫秒为单位）。</td></tr><tr><td>KAVG&#x2F;cmd</td><td>这是命令在 VMkernel 中花费的时间。</td></tr><tr><td>GAVG&#x2F;cmd</td><td>是指客户机操作系统感知的响应时间。该值使用此公式计算： DAVG + KAVG &#x3D; GAVG</td></tr></tbody></table><p>上述列既适用于读取操作，也适用于写入操作，而 xAVG&#x2F;rd 只适用于读取操作，xAVG&#x2F;wr 只适用于写入操作。将这些列的结合起来是监控性能的最好方式，但是高读取或写入响应时间可能表示该阵列上的读取或写入缓存处于禁用状态。所有阵列的执行方式都不同，但对于持续的时间段<br>DAVG&#x2F;cmd、KAVG&#x2F;cmd 和 GAVG&#x2F;cmd 不应超出<strong>10 毫秒</strong> (ms)。</p><p>如果响应时间增加到超过 5000 毫秒（或 5 秒），则 VMware ESX 将让命令超时并中止操作。这些事件已记入日志；可以在以下日志中查看中止消息和其他 SCSI 错误：</p><ul><li>ESX 3.5 和 4.x – &#x2F;var&#x2F;log&#x2F;vmkernel</li><li>ESXi 3.5 和 4.x – &#x2F;var&#x2F;log&#x2F;messages</li><li>ESXi 5.x 及更高版本 - &#x2F;var&#x2F;log&#x2F;vmkernel.log</li></ul><h2 id="存储性能问题分析"><a href="#存储性能问题分析" class="headerlink" title="存储性能问题分析"></a>存储性能问题分析</h2><p>如果同存储设备的所有LUN均出现 DAVG&#x2F;cmd 超出<strong>10 毫秒</strong> (ms)，甚至达到惊人的几十毫秒或者上百上千毫秒，就需要通过以下方式进一步分析根因。</p><ul><li>FC SAN环境：从光纤交换机上查看光衰是否正常，从而确认是否需要更换光纤线或光模块。</li><li>IP SAN环境：确认iSCSi网卡和以太网交换机的线路或光模块是否异常。</li></ul><p>如果单个LUN出现 DAVG&#x2F;cmd 超出<strong>10 毫秒</strong> (ms)，甚至达到惊人的几十毫秒或者上百上千毫秒，在其他LUN的运行正常前提下需要确认是否是存储LUN本身 I&#x2F;O 性能不足导致的该问题。</p><p><a href="https://communities.vmware.com/t5/Storage-Performance/Interpreting-esxtop-Statistics/ta-p/2776936" title="esxtop的详细指标说明">esxtop的详细指标说明</a></p>]]></content>
    
    
    <summary type="html">这篇文章讲解了如何识别ESXi存储性能问题。当虚拟机响应时间过长，存储路径延迟的报警发生时，可以使用交互式esxtop查看I/O指标，启用ESXi Shell和SSH访问，监控每个HBA的存储性能，每个LUN监控存储性能，按每个虚拟机监控存储性能。各个指标具体说明，如DAVG/cmd、GAVG/cmd、xAVG/rd，如果超出正常范围，需进一步分析根因。</summary>
    
    
    
    <category term="经验分享" scheme="https://lhliang.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="VMware" scheme="https://lhliang.com/tags/VMware/"/>
    
    <category term="ESXi" scheme="https://lhliang.com/tags/ESXi/"/>
    
    <category term="vSphere" scheme="https://lhliang.com/tags/vSphere/"/>
    
  </entry>
  
  <entry>
    <title>北京六月的天空</title>
    <link href="https://lhliang.com/p/83d35df9.html"/>
    <id>https://lhliang.com/p/83d35df9.html</id>
    <published>2022-06-05T16:00:00.000Z</published>
    <updated>2024-03-17T03:17:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>北京2022年6月6日海淀天气晴</p>]]></content>
    
    
    <summary type="html">这篇文章介绍了北京2022年6月6日海淀天气晴,由于UP删除了视频，所以无法显示视频了。</summary>
    
    
    
    <category term="生活日常" scheme="https://lhliang.com/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="sky" scheme="https://lhliang.com/tags/sky/"/>
    
    <category term="vlog" scheme="https://lhliang.com/tags/vlog/"/>
    
  </entry>
  
  <entry>
    <title>Linux 网卡绑定配置大全</title>
    <link href="https://lhliang.com/p/b4fe59ce.html"/>
    <id>https://lhliang.com/p/b4fe59ce.html</id>
    <published>2021-12-01T10:26:26.000Z</published>
    <updated>2024-03-16T14:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>网卡绑定使两个或多个网络接口能够充当一个接口，同时增大带宽并提供冗余。</p><blockquote><p>active-backup、balance-tlb 和 balance-alb 模式不需要对交换机进行任何具体的配 置。其他绑定模式需要配置交换机来聚合链接。</p></blockquote><p>最新的操作系统可以通过文本用户界面工具 <code>nmtui</code> 可用于在终端窗口中配置绑定</p><pre><code class="bash">nmtui</code></pre><p>由于nmtui可以解决大多数问题，本文提供的是命令行手动配置bond方式，请自行选择配置方式。</p><h2 id="绑定模式概述"><a href="#绑定模式概述" class="headerlink" title="绑定模式概述"></a>绑定模式概述</h2><table><thead><tr><th>模式</th><th>交换机要求</th><th>特性概述</th></tr></thead><tbody><tr><td>0 - balance-rr</td><td>需要启用静态的 Etherchannel(未启用 LACP 协商)</td><td>为容错和负载平衡设置循环策略。从第一个可用的接口开始，在每个绑定的从接口上依次接收和发送传输。</td></tr><tr><td>1 - active-backup</td><td>需要指定主端口</td><td>为容错设置主动备份策略。通过第一个可用的绑定从接口接收和发送传输。仅当活动的绑定从属接口出现故障时，才使用另一个绑定从属接口。</td></tr><tr><td>2 - balance-xor</td><td>需要启用静态的 Etherchannel(未启用 LACP 协商)</td><td>为容错和负载平衡设置 XOR（异或）策略。使用此方法，接口将传入请求的 MAC 地址与其中一个从属 NIC 的 MAC 地址相匹配。一旦建立此链路，就会从第一个可用接口开始顺序发送传输。</td></tr><tr><td>3 - broadcast</td><td>需要启用静态的 Etherchannel(未启用 LACP 协商)</td><td>为容错设置广播策略。所有传输都在所有从接口上发送。</td></tr><tr><td>4 - 802.3ad</td><td>需要启用 LACP 协商的 Etherchannel</td><td>设置 IEEE 802.3ad 动态链路聚合策略。创建共享相同速度和双工设置的聚合组。在活动聚合器中的所有从属设备上发送和接收。需要符合 802.3ad 的交换机。</td></tr><tr><td>5 - balance-tlb</td><td>需要指定主端口</td><td>为容错和负载平衡设置传输负载平衡 (TLB) 策略。根据每个从接口上的当前负载分配传出流量。当前从站接收传入流量。如果接收从机发生故障，另一个从机接管故障从机的 MAC 地址。</td></tr><tr><td>6 - balance-alb</td><td>需要指定主端口</td><td>指定主设备的接口名称，例如 eth0。主设备是第一个使用的绑定接口，除非失败，否则不会放弃。当绑定接口中的一个 NIC 速度更快并因此能够处理更大的负载时，此设置特别有用。此设置仅在绑定接口处于主动备份模式时有效。</td></tr></tbody></table><h2 id="配置环境介绍"><a href="#配置环境介绍" class="headerlink" title="配置环境介绍"></a>配置环境介绍</h2><p>Linux地址：192.168.0.1<br>Linux网关：192.168.0.254</p><p>网口1：eth0   3c:ab:0e:35:fc:18<br>网口2：eth1   3c:ab:0e:35:fc:19</p><h2 id="绑定模式-0-配置脚本"><a href="#绑定模式-0-配置脚本" class="headerlink" title="绑定模式 0 配置脚本"></a>绑定模式 0 配置脚本</h2><h3 id="RHEL5"><a href="#RHEL5" class="headerlink" title="RHEL5"></a>RHEL5</h3><pre><code class="bash">#!/bin/bashethtool eth0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiecho alias bond0 bonding &gt;&gt;  /etc/modprobe.confset_rhel5_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel5_bond_config -b bond0 -m 0 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel5_ethx_config()  &#123;    bond_name=$1    eth_name=$2    mac_address=`cat /sys/class/net/$eth_name/address`    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesHWADDR=$mac_addressMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel5_ethx_config bond0 eth0set_rhel5_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL6"><a href="#RHEL6" class="headerlink" title="RHEL6"></a>RHEL6</h3><pre><code class="bash">#!/bin/bashethtool eth0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiset_rhel6_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel6_bond_config -b bond0 -m 0 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel6_ethx_config()  &#123;    bond_name=$1    eth_name=$2    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel6_ethx_config bond0 eth0set_rhel6_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL7"><a href="#RHEL7" class="headerlink" title="RHEL7"></a>RHEL7</h3><pre><code class="bash">#!/bin/bashnmcli con add type bond ifname bond0 bond.options &quot;mode=balance-rr,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet ifname eth0 master bond0nmcli connection add type ethernet ifname eth1 master bond0nmcli connection up eth0nmcli connection up eth1nmcli connection up bond0</code></pre><h3 id="RHEL8-9"><a href="#RHEL8-9" class="headerlink" title="RHEL8 9"></a>RHEL8 9</h3><pre><code class="bash">#!/bin/bashnmcli connection add type bond con-name bond0 ifname bond0 bond.options &quot;mode=balance-rr,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet slave-type bond con-name eth0 ifname eth0 master bond0nmcli connection add type ethernet slave-type bond con-name eth1 ifname eth1 master bond0nmcli connection up eth0nmcli connection up eth1nmcli connection up bond0</code></pre><h2 id="绑定模式-1-配置脚本"><a href="#绑定模式-1-配置脚本" class="headerlink" title="绑定模式 1 配置脚本"></a>绑定模式 1 配置脚本</h2><h3 id="RHEL5-1"><a href="#RHEL5-1" class="headerlink" title="RHEL5"></a>RHEL5</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiecho alias bond0 bonding &gt;&gt;  /etc/modprobe.confset_rhel5_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel5_bond_config -b bond0 -m 1 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100 primary=eht0&quot;set_rhel5_ethx_config()  &#123;    bond_name=$1    eth_name=$2    mac_address=`cat /sys/class/net/$eth_name/address`    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesHWADDR=$mac_addressMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel5_ethx_config bond0 eht0set_rhel5_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL6-1"><a href="#RHEL6-1" class="headerlink" title="RHEL6"></a>RHEL6</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiset_rhel6_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel6_bond_config -b bond0 -m 1 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100 primary=eht0&quot;set_rhel6_ethx_config()  &#123;    bond_name=$1    eth_name=$2    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel6_ethx_config bond0 eht0set_rhel6_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL7-1"><a href="#RHEL7-1" class="headerlink" title="RHEL7"></a>RHEL7</h3><pre><code class="bash">#!/bin/bashnmcli con add type bond ifname bond0 bond.options &quot;mode=active-backup,primary=eht0,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet ifname eht0 master bond0nmcli connection add type ethernet ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h3 id="RHEL8-9-1"><a href="#RHEL8-9-1" class="headerlink" title="RHEL8 9"></a>RHEL8 9</h3><pre><code class="bash">#!/bin/bashnmcli connection add type bond con-name bond0 ifname bond0 bond.options &quot;mode=active-backup,primary=eht0,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet slave-type bond con-name eht0 ifname eht0 master bond0nmcli connection add type ethernet slave-type bond con-name eth1 ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h2 id="绑定模式-2-配置脚本"><a href="#绑定模式-2-配置脚本" class="headerlink" title="绑定模式 2 配置脚本"></a>绑定模式 2 配置脚本</h2><h3 id="RHEL5-2"><a href="#RHEL5-2" class="headerlink" title="RHEL5"></a>RHEL5</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiecho alias bond0 bonding &gt;&gt;  /etc/modprobe.confset_rhel5_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel5_bond_config -b bond0 -m 2 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100 xmit_hash_policy=layer3+4&quot;set_rhel5_ethx_config()  &#123;    bond_name=$1    eth_name=$2    mac_address=`cat /sys/class/net/$eth_name/address`    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesHWADDR=$mac_addressMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel5_ethx_config bond0 eht0set_rhel5_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL6-2"><a href="#RHEL6-2" class="headerlink" title="RHEL6"></a>RHEL6</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiset_rhel6_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel6_bond_config -b bond0 -m 2 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100 xmit_hash_policy=layer3+4&quot;set_rhel6_ethx_config()  &#123;    bond_name=$1    eth_name=$2    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel6_ethx_config bond0 eht0set_rhel6_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL7-2"><a href="#RHEL7-2" class="headerlink" title="RHEL7"></a>RHEL7</h3><pre><code class="bash">#!/bin/bashnmcli con add type bond ifname bond0 bond.options &quot;mode=balance-xor,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet ifname eht0 master bond0nmcli connection add type ethernet ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h3 id="RHEL8-9-2"><a href="#RHEL8-9-2" class="headerlink" title="RHEL8 9"></a>RHEL8 9</h3><pre><code class="bash">#!/bin/bashnmcli connection add type bond con-name bond0 ifname bond0 bond.options &quot;mode=balance-xor,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet slave-type bond con-name eht0 ifname eht0 master bond0nmcli connection add type ethernet slave-type bond con-name eth1 ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h2 id="绑定模式-3-配置脚本"><a href="#绑定模式-3-配置脚本" class="headerlink" title="绑定模式 3 配置脚本"></a>绑定模式 3 配置脚本</h2><h3 id="RHEL5-3"><a href="#RHEL5-3" class="headerlink" title="RHEL5"></a>RHEL5</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiecho alias bond0 bonding &gt;&gt;  /etc/modprobe.confset_rhel5_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel5_bond_config -b bond0 -m 3 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel5_ethx_config()  &#123;    bond_name=$1    eth_name=$2    mac_address=`cat /sys/class/net/$eth_name/address`    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesHWADDR=$mac_addressMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel5_ethx_config bond0 eht0set_rhel5_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL6-3"><a href="#RHEL6-3" class="headerlink" title="RHEL6"></a>RHEL6</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiset_rhel6_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel6_bond_config -b bond0 -m 3 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel6_ethx_config()  &#123;    bond_name=$1    eth_name=$2    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel6_ethx_config bond0 eht0set_rhel6_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL7-3"><a href="#RHEL7-3" class="headerlink" title="RHEL7"></a>RHEL7</h3><pre><code class="bash">#!/bin/bashnmcli con add type bond ifname bond0 bond.options &quot;mode=broadcast,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet ifname eht0 master bond0nmcli connection add type ethernet ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h3 id="RHEL8-9-3"><a href="#RHEL8-9-3" class="headerlink" title="RHEL8 9"></a>RHEL8 9</h3><pre><code class="bash">#!/bin/bashnmcli connection add type bond con-name bond0 ifname bond0 bond.options &quot;mode=broadcast,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet slave-type bond con-name eht0 ifname eht0 master bond0nmcli connection add type ethernet slave-type bond con-name eth1 ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h2 id="绑定模式-4-配置脚本"><a href="#绑定模式-4-配置脚本" class="headerlink" title="绑定模式 4 配置脚本"></a>绑定模式 4 配置脚本</h2><h3 id="RHEL5-4"><a href="#RHEL5-4" class="headerlink" title="RHEL5"></a>RHEL5</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiecho alias bond0 bonding &gt;&gt;  /etc/modprobe.confset_rhel5_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel5_bond_config -b bond0 -m 4 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100 xmit_hash_policy=layer2+3&quot;set_rhel5_ethx_config()  &#123;    bond_name=$1    eth_name=$2    mac_address=`cat /sys/class/net/$eth_name/address`    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesHWADDR=$mac_addressMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel5_ethx_config bond0 eht0set_rhel5_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL6-4"><a href="#RHEL6-4" class="headerlink" title="RHEL6"></a>RHEL6</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiset_rhel6_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel6_bond_config -b bond0 -m 4 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100 xmit_hash_policy=layer2+3&quot;set_rhel6_ethx_config()  &#123;    bond_name=$1    eth_name=$2    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel6_ethx_config bond0 eht0set_rhel6_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL7-4"><a href="#RHEL7-4" class="headerlink" title="RHEL7"></a>RHEL7</h3><pre><code class="bash">#!/bin/bashnmcli con add type bond ifname bond0 bond.options &quot;mode=802.3ad,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet ifname eht0 master bond0nmcli connection add type ethernet ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h3 id="RHEL8-9-4"><a href="#RHEL8-9-4" class="headerlink" title="RHEL8 9"></a>RHEL8 9</h3><pre><code class="bash">#!/bin/bashnmcli connection add type bond con-name bond0 ifname bond0 bond.options &quot;mode=802.3ad,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet slave-type bond con-name eht0 ifname eht0 master bond0nmcli connection add type ethernet slave-type bond con-name eth1 ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h2 id="绑定模式-5-配置脚本"><a href="#绑定模式-5-配置脚本" class="headerlink" title="绑定模式 5 配置脚本"></a>绑定模式 5 配置脚本</h2><h3 id="RHEL5-5"><a href="#RHEL5-5" class="headerlink" title="RHEL5"></a>RHEL5</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiecho alias bond0 bonding &gt;&gt;  /etc/modprobe.confset_rhel5_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel5_bond_config -b bond0 -m 5 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel5_ethx_config()  &#123;    bond_name=$1    eth_name=$2    mac_address=`cat /sys/class/net/$eth_name/address`    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesHWADDR=$mac_addressMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel5_ethx_config bond0 eht0set_rhel5_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL6-5"><a href="#RHEL6-5" class="headerlink" title="RHEL6"></a>RHEL6</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiset_rhel6_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel6_bond_config -b bond0 -m 5 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel6_ethx_config()  &#123;    bond_name=$1    eth_name=$2    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel6_ethx_config bond0 eht0set_rhel6_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL7-5"><a href="#RHEL7-5" class="headerlink" title="RHEL7"></a>RHEL7</h3><pre><code class="bash">#!/bin/bashnmcli con add type bond ifname bond0 bond.options &quot;mode=balance-tlb,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet ifname eht0 master bond0nmcli connection add type ethernet ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h3 id="RHEL8-9-5"><a href="#RHEL8-9-5" class="headerlink" title="RHEL8 9"></a>RHEL8 9</h3><pre><code class="bash">#!/bin/bashnmcli connection add type bond con-name bond0 ifname bond0 bond.options &quot;mode=balance-tlb,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet slave-type bond con-name eht0 ifname eht0 master bond0nmcli connection add type ethernet slave-type bond con-name eth1 ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h2 id="绑定模式-6-配置脚本"><a href="#绑定模式-6-配置脚本" class="headerlink" title="绑定模式 6 配置脚本"></a>绑定模式 6 配置脚本</h2><h3 id="RHEL5-6"><a href="#RHEL5-6" class="headerlink" title="RHEL5"></a>RHEL5</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiecho alias bond0 bonding &gt;&gt;  /etc/modprobe.confset_rhel5_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel5_bond_config -b bond0 -m 6 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel5_ethx_config()  &#123;    bond_name=$1    eth_name=$2    mac_address=`cat /sys/class/net/$eth_name/address`    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesHWADDR=$mac_addressMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel5_ethx_config bond0 eht0set_rhel5_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL6-6"><a href="#RHEL6-6" class="headerlink" title="RHEL6"></a>RHEL6</h3><pre><code class="bash">#!/bin/bashethtool eht0 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eht0    exit 1fiethtool eth1 |grep &quot;Link detected: yes&quot;&gt; /dev/nullif [ $? -ne 0 ] ;then    echo Can not detect the link of eth1    exit 1fiset_rhel6_bond_config ()&#123;unset OPTINDwhile getopts &#39;b:m:i:n:g:s:t:&#39; opt; do    case $opt in        b) bond_name=$OPTARG;;        m) bond_mode=$OPTARG;;        i) ip=$OPTARG;;        n) mask=$OPTARG;;        g) gateway=$OPTARG;;        s) bond_opts=$OPTARG;;        t) network_type=$OPTARG;;    esacdonebond_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$bond_name&quot;echo $bond_config_fileif [ -f $bond_config_file ]; then    echo &quot;Backup original $bond_config_file to bondhelper.$bond_name&quot;    mv $bond_config_file /etc/sysconfig/network-scripts/bondhelper.$bond_name -ffiif [ &quot;static&quot; == $network_type ]; then     if [ ! -n &quot;$gateway&quot; ]; then        ip_setting=&quot;IPADDR=$ipNETMASK=$maskUSERCTL=no&quot;    else        ip_setting=&quot;IPADDR=$ipNETMASK=$maskGATEWAY=$gatewayUSERCTL=no&quot;    fielse    ip_setting=&quot;USERCTL=no&quot;ficat &lt;&lt; EOF &gt; $bond_config_fileDEVICE=$bond_nameONBOOT=yesBOOTPROTO=$network_type$ip_settingBONDING_OPTS=&quot;mode=$bond_mode $bond_opts&quot;NM_CONTROLLED=noEOF&#125;set_rhel6_bond_config -b bond0 -m 6 -i 192.168.0.1 -n 255.255.255.0 -g 192.168.0.254 -t static -s &quot;miimon=100&quot;set_rhel6_ethx_config()  &#123;    bond_name=$1    eth_name=$2    eth_config_file=&quot;/etc/sysconfig/network-scripts/ifcfg-$eth_name&quot;    if [ -f $eth_config_file ]; then        echo &quot;Backup original $eth_config_file to bondhelper.$eth_name&quot;        mv $eth_config_file /etc/sysconfig/network-scripts/bondhelper.$eth_name -f    fi    cat &lt;&lt; EOF  &gt; $eth_config_fileDEVICE=$eth_nameBOOTPROTO=noneONBOOT=yesMASTER=$bond_nameSLAVE=yesUSERCTL=noNM_CONTROLLED=noEOF&#125;set_rhel6_ethx_config bond0 eht0set_rhel6_ethx_config bond0 eth1echo &quot;Network service will be restarted.&quot;service network restartcat /proc/net/bonding/bond0</code></pre><h3 id="RHEL7-6"><a href="#RHEL7-6" class="headerlink" title="RHEL7"></a>RHEL7</h3><pre><code class="bash">#!/bin/bashnmcli con add type bond ifname bond0 bond.options &quot;mode=balance-alb,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet ifname eht0 master bond0nmcli connection add type ethernet ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre><h3 id="RHEL8-9-6"><a href="#RHEL8-9-6" class="headerlink" title="RHEL8 9"></a>RHEL8 9</h3><pre><code class="bash">#!/bin/bashnmcli connection add type bond con-name bond0 ifname bond0 bond.options &quot;mode=balance-alb,miimon=100&quot;nmcli connection modify bond0 ipv4.addresses &#39;192.168.0.1/24&#39;nmcli connection modify bond0 ipv4.gateway &#39;192.168.0.254&#39;nmcli connection modify bond0 ipv4.method manualnmcli connection add type ethernet slave-type bond con-name eht0 ifname eht0 master bond0nmcli connection add type ethernet slave-type bond con-name eth1 ifname eth1 master bond0nmcli connection up eht0nmcli connection up eth1nmcli connection up bond0</code></pre>]]></content>
    
    
    <summary type="html">这篇文章讲解了Linux网卡绑定配置方法，在不同的绑定模式下，提供了相应的配置脚本，并介绍了配置环境。同时也列出了相关的IP地址和网口信息。绑定模式0-6逐一介绍，包括在RHEL5-9版本下配置脚本的方法。</summary>
    
    
    
    <category term="学习笔记" scheme="https://lhliang.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://lhliang.com/tags/Linux/"/>
    
    <category term="网卡绑定" scheme="https://lhliang.com/tags/%E7%BD%91%E5%8D%A1%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
</feed>
